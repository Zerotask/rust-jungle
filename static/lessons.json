{"total":78,"stages":[1,2,3,4,5,6,7,8,9,10],"pages":[{"url":"http://localhost:15007/en/stages/1/changing-variables","language":"en","stage":1,"index":4,"title":"Changing Variables","previous":"variables","next":"basic-types","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A","content":"Rust cares a great deal about what variables are modifiable. Values fall into two types:\nmutable - the compiler will allow the variable to be written to and read from.\nimmutable - the compiler will only allow the variable to be read from.\nMutable values are denoted with a mut keyword.\nWe will have more to say on this concept later, but for now just keep an eye out for this keyword."},{"url":"http://localhost:15007/en/stages/1/constants","language":"en","stage":1,"index":7,"title":"Constants","previous":"basic-type-conversion","next":"arrays","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A","content":"Constants allow us to specify a common value that's used throughout our code many times efficiently. Instead of copying values like variables where they are used, constants directly replace the text identifier where they are used with their value at compile time.\nUnlike variables, constants must always have explicit types.\nConstant names are always in SCREAMING_SNAKE_CASE."},{"url":"http://localhost:15007/en/stages/1/functions","language":"en","stage":1,"index":9,"title":"Functions","tags":["functions"],"previous":"arrays","next":"multiple-return-values","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20subtract(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20-%20y%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%2242%20%2B%2013%20%3D%20%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%20%20%20%20println!(%2242%20-%2013%20%3D%20%7B%7D%22%2C%20subtract(42%2C%2013))%0A%7D%0A","furtherInformation":["https://doc.rust-lang.org/book/ch03-03-how-functions-work.html"],"content":"A function has zero or more parameters.\nIn this example, the add function takes two arguments of type i32 (signed integer of 32-bit length).\nIf you just want to return an expression, you can drop the return keyword and the semicolon at the end, as we did in the subtract function.\nFunction names are always in snake_case.\nHint: if you define a function, the data it accepts are called parameters. If you call that function and pass data to it, then it's called arguments."},{"url":"http://localhost:15007/en/stages/1/","language":"en","stage":1,"index":1,"title":"Introduction","next":"the-rust-playground","content":"In the first stage we're going to be exploring the very basics with functions, variables, and the most primitive types. Glad to have you on board!\nAlso! In case you are wondering who this adorable crab who is speaking to you is, I am Ferris, the unofficial mascot for the Rust programming language. Nice to meet you.\nOnce you get familiar with Rust, you can call yourself a Rustacean. That's how people who use, contribute or are interested in Rust call themself.\nSome lessons will provide further information from the following official sources:\nRust Book\nRust by Example\nthe docs website (docs.rs)"},{"url":"http://localhost:15007/en/stages/1/macros","language":"en","stage":1,"index":12,"title":"Macros","previous":"returning-nothing","next":"compiler-messages","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Example%20from%20the%20actual%20vec!%20macro.%0A%23%5Bmacro_export%5D%0Amacro_rules!%20vec2%20%7B%0A%20%20%20%20(%20%24(%20%24x%3Aexpr%20)%2C*%20)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20temp_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20temp_vec.push(%24x)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20)*%0A%20%20%20%20%20%20%20%20%20%20%20%20temp_vec%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20You%20can%20change%20that%20from%20vec2!%20to%20vec!%20and%20have%20the%20same%20output.%0A%20%20%20%20let%20a%20%3D%20vec2!%5B%22hello%22%2C%20%22world%22%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20a)%3B%0A%7D%0A","furtherInformation":["https://doc.rust-lang.org/reference/macros.html","https://doc.rust-lang.org/book/ch19-06-macros.html"],"content":"We’ve used macros like println! throughout this stage, but we haven’t fully explored what a macro is and how it works. The term macro refers to a family of features in Rust: declarative macros with macro_rules! and three kinds of procedural macros:\nCustom #[derive] macros that specify code added with the derive attribute used on structs and enums\nAttribute-like macros that define custom attributes usable on any item\nFunction-like macros that look like function calls but operate on the tokens specified as their argument\nTo distinguish it from functions, macros are a way of writing code that writes other code, which is known as metaprogramming\nYou can write your own macros with macro_rules!"},{"url":"http://localhost:15007/en/stages/1/multiple-return-values","language":"en","stage":1,"index":10,"title":"Multiple Return Values","previous":"functions","next":"returning-nothing","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A","content":"Functions can return multiple values by returning a tuple of values.\nTuple elements can be referenced by their index number.\nRust supports various kinds of destructuring that we will see in many forms, allowing us to extract sub-pieces of data structures in ergonomic ways. Be on the lookout!"},{"url":"http://localhost:15007/en/stages/1/returning-nothing","language":"en","stage":1,"index":11,"title":"Returning Nothing","previous":"multiple-return-values","next":"macros","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A","content":"If no return type is specified for a function, it returns an empty tuple, also known as a unit.\nAn empty tuple is represented by ().\nUsing () is uncommon, but will come up often enough that it's good to know whats happening."},{"url":"http://localhost:15007/en/stages/1/summary","language":"en","stage":1,"index":14,"title":"Summary","previous":"compiler-messages","content":"Nice job so far! The basics of Rust aren't so bad, right? We're getting a peek into how the Rust compiler thinks. As a system programming language it cares a lot about the size of values in memory, whether things can be modified or not, and making sure your math is what you want it to be.\nIn the next stage we will learn how to install Rust locally and how to develop and test a very simple program."},{"url":"http://localhost:15007/en/stages/1/the-rust-playground","language":"en","stage":1,"index":2,"title":"The Rust Playground","previous":"./","next":"variables","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A","content":"Rust Jungle uses an interactive coding tool from Rust Playground.\nIt's a great way to play around with Rust and show others your creativity and challenges!\nBesides the Rust Playground we use a code highlighting for Rust language specific parts in the text and italic for other special words or phrases.\nAfter you learned the very basics, you will learn in stage 2 how to develop with Rust locally."},{"url":"http://localhost:15007/en/stages/1/variables","language":"en","stage":1,"index":3,"title":"Variables","previous":"the-rust-playground","next":"changing-variables","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A","content":"Variables are declared using the let keyword.\nWhen assigning a value, Rust will be able to infer the type of your variable 99% of the time. If it cannot you may add the type to your variable declaration.\nNotice how we can assign to the same variable name multiple times. This is called variable shadowing and the type can be changed for subsequent references to that name.\nVariable names are always in snake_case."},{"url":"http://localhost:15007/en/stages/10/creating-modules","language":"en","stage":10,"index":7,"title":"Creating Modules","previous":"referencing-multiple-items","next":"module-hierarchy","content":"When we think of code, we usually imagine a hierarchy of files organized in directories. Rust lets you create modules closely related to your file structure.\nThere are two ways in Rust to declare a module. For example, a module foo can be represented as:\na file named foo.rs\na directory named foo with a file mod.rs inside"},{"url":"http://localhost:15007/en/stages/10/exporting","language":"en","stage":10,"index":11,"title":"Exporting","previous":"internal-module-referencing","next":"struct-visibility","content":"By default members of a module are not accessible from outside of the module (not even to its child modules!). We make members of a module accessible using the pub keyword.\nBy default members of a crate are not accessible outside of the crate. We make members of a crate accessible by marking them as pub in the root module of your crate (lib.rs or main.rs)."},{"url":"http://localhost:15007/en/stages/10/","language":"en","stage":10,"index":1,"title":"Introduction","next":"modules","content":"So far all of our code examples have been a single file. Let's discuss how our code can be better organized and shared by others!"},{"url":"http://localhost:15007/en/stages/10/inline-modules","language":"en","stage":10,"index":9,"title":"Inline Modules","previous":"module-hierarchy","next":"internal-module-referencing","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20foo%20%7B%0D%0A%20%20%20%20pub%20fn%20bar()%20%7B%0D%0A%20%20%20%20%20%20%20%20println!(%22Hello%20from%20module%20foo!%22)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20%0D%0A%20%20%20%20pub%20mod%20nested%20%7B%0D%0A%20%20%20%20%20%20%20%20pub%20fn%20bar()%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22Hello%20from%20foo's%20nested%20module!%22)%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afn%20main()%20%7B%0D%0A%20%20%20%20foo%3A%3Abar()%3B%0D%0A%20%20%20%20foo%3A%3Anested%3A%3Abar()%3B%0D%0A%7D%0D%0A","content":"A sub-module can be directly inlined within a module's code.\nOne very common use for inline modules is creating unit tests. We create an inline module that only exists when Rust is used for testing! You already saw an example in a previous lesson.\nYou can also define modules inside modules, often called nested modules."},{"url":"http://localhost:15007/en/stages/10/summary","language":"en","stage":10,"index":17,"title":"Summary","previous":"rust-editions","content":"You now have a few tricks up your sleeve when it comes to creating Rust applications and libraries ready for the world. Don't worry about remembering it all. As your library grows and is used by other people, you'll find what works best at each milestone.\nIf you want to practice your new Rust skills, I can recommend you Rustlings. This is an interactive tutorial by the Rust team."},{"url":"http://localhost:15007/en/stages/10/writing-a-library","language":"en","stage":10,"index":4,"title":"Writing A Library","previous":"writing-a-program","next":"referencing-other-modules-and-crates","content":"A library has a root module in a file called lib.rs.\nYou can use cargo to create a new libray if you append the --lib flag, e. g. cargo new my-library --lib.\nThis will create a src/lib.rs file for you."},{"url":"http://localhost:15007/en/stages/10/writing-a-program","language":"en","stage":10,"index":3,"title":"Writing A Program","tags":["program"],"previous":"modules","next":"writing-a-library","content":"A program has a root module in a file called main.rs.\nYou can use cargo to create a new program, e. g. cargo new my-program.\nThis will create a src/main.rs file for you."},{"url":"http://localhost:15007/en/stages/10/your-own-prelude","language":"en","stage":10,"index":14,"title":"Your Own Prelude","previous":"prelude","next":"cargo-toml-file","content":"Because of standard library's prelude, it's common for your libary to have its own prelude module as a starting point for where users should import all of the most common data structures for using your library (e.g use my_library::prelude::*). It doesn't automatically get used in programs/libraries that use your crate, but it's a good convention to follow so people know where to start.\nFerris says, \"Be a good rustacean and help a fellow crab out with a good prelude!\""},{"url":"http://localhost:15007/en/stages/2/cargo-subcommands","language":"en","stage":2,"index":6,"title":"Cargo Subcommands","tags":["cargo"],"previous":"managing-dependencies-with-cargo","next":"setup-visual-studio-code","content":"cargo subcommands are an option to add additional commands which are developed by the community to customize your developing experience.\nTo install a cargo subcommand, you simply run: cargo install name-of-subcommand\nFor example to install the cargo-watch subcommand, you simply run: cargo install cargo-watch.\nTo see all available option for this new cargo subcommand, just run: cargo watch --help\ncargo watch is a pretty useful command to run or test your code everytime something has changed. It can be used like: cargo watch -x run. This would execute cargo run whenever it detects a change.\nThere are other useful commands like cargo-edit which adds multiple subcommands (cargo add, cargo rm and cargo upgrade) to handle dependencies via CLI commands.\nFurther cargo subcommands can be found here:"},{"url":"http://localhost:15007/en/stages/2/","language":"en","stage":2,"index":1,"title":"Introduction","next":"installation","content":"In this stage you will learn how to install Rust locally and you will learn about some important Rust tools like rustup (the Rust toolchain installer) and cargo (Rust's package manager).\nYou will also learn how to write and test your own Rust programs with Visual Studio Code."},{"url":"http://localhost:15007/en/stages/2/installation","language":"en","stage":2,"index":2,"title":"Installation","previous":"./","next":"rustup","content":"The recommended way to install Rust and its tools is to download rustup, Rust's toolchain manager.\nYou can download it here: https://www.rust-lang.org/tools/install (RUSTUP-INIT)\nAfter the installation you can run rustc --version (Rust's compiler) to check, if it's installed properly."},{"url":"http://localhost:15007/en/stages/2/managing-dependencies-with-cargo","language":"en","stage":2,"index":5,"title":"Managing Dependencies With Cargo","tags":["cargo"],"previous":"cargo","next":"cargo-subcommands","content":"At first, you have to create a workspace (project) with either cargo new my-project or cargo init.\nThis will create a Cargo.toml file in the root folder. This is your centralized configuration file for your Rust program. Within that file you can pass meta data like author or a version and it's also used to manage the dependencies for your program.\nUnlike other package manager (like npm for example) there is no CLI command to handle dependencies. In Rust you have to add it to Cargo.toml and the compiler will take care of them.\nThis will add the 3 dependencies git2, webbrowser and zip to your project. The next time you compile your program, those dependencies will get downloaded and compiled.\nTo search for packages, or crates how Rust calls it, you can:\nrun cargo search crate-name\nopen the Rust community’s crate registry:\nopen the unofficial crates.io alternative which offers categories for crates:\nTo update your dependencies, you simply run: cargo update\nIn the next lesson you will learn how to add cargo subcommands (sometimes called Rust binarier)."},{"url":"http://localhost:15007/en/stages/2/setup-visual-studio-code","language":"en","stage":2,"index":7,"title":"Setup Visual Studio Code","previous":"cargo-subcommands","next":"writing-a-hello-world-program","content":"I recommend using Visual Studio Code for developing Rust programs.\nVisual Studio Code is a modular editor which can be extended with with useful tools (called extensions) to improve your developing experience for Rust programming.\nBesides the official Rust extension there are also extension packs which offers some additional tools often needed for Rust programming, e. g. an extension for TOML files.\nI can recommend you an extension pack of my own, which you can find here: Rust Extension Pack."},{"url":"http://localhost:15007/en/stages/2/summary","language":"en","stage":2,"index":11,"title":"Summary","previous":"how-to-test-functions","content":"In this stage you learned how to install Rust locally. You learned about the Rust tools rustup and cargo\nNow you know how to manage dependencies with cargo and extend it with cargo subcommands.\nYou also learned how to setup Visual Studio Code and you wrote your first Rust programs.\nNext up we'll be looking at some old friends: if tests and for loops."},{"url":"http://localhost:15007/en/stages/2/writing-a-hello-world-program","language":"en","stage":2,"index":8,"title":"Writing A Hello World Program","tags":["program"],"previous":"setup-visual-studio-code","next":"reading-command-line-arguments","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%2C%20world!%22)%3B%0A%7D%0A","content":"You can create a new file main.rs and put the code from the Rust Playground in it\nor you can use cargo to create a new project with either cargo new hello-world or cargo init\ncargo will automatically create a src/main.rs for you which already has a Hello, world! output in it.\nIf you chose cargo to create a basic project for you, all you have to do is to run: cargo run in a terminal and you should see the output: Hello, world!\nIf you created a main.rs without cargo, you have to use the Rust compiler rustc and run: rustc main.rs.\nThis will create a main.exe in the same directory. Now you have to execute this compiled file (./main.exe) and you will see the same output.\nIn a later lesson you will also learn how to split your code into multiple files."},{"url":"http://localhost:15007/en/stages/3/","language":"en","stage":3,"index":1,"title":"Introduction","next":"if-else","content":"In this chapter let's talk about basic control flow methods in Rust. If you are familiar with C based languages you'll feel right at home and maybe enjoy a surprise or two."},{"url":"http://localhost:15007/en/stages/3/loop","language":"en","stage":3,"index":3,"title":"loop","tags":["iteration"],"previous":"if-else","next":"returning-values-from-loop","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A","content":"Need an infinite loop? Rust makes it easy.\nbreak will escape a loop when you are ready.\nloop has a secret we'll talk about soon."},{"url":"http://localhost:15007/en/stages/3/returning-values-from-loop","language":"en","stage":3,"index":4,"title":"Returning Values From Loop","tags":["iteration"],"previous":"loop","next":"while","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22found%20the%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A","content":"loop can break to return a value. This is used to assign a value to a variable."},{"url":"http://localhost:15007/en/stages/3/summary","language":"en","stage":3,"index":9,"title":"Summary","previous":"returning-values-from-block-expressions","content":"Hopefully I've shown a glimpse of Rust's power even in the most basic language features. We'll be talking about for and match even more in depth as we gain more knowledge that can utilize their capabilities. Next time we'll get into Rust's foundational data structures."},{"url":"http://localhost:15007/en/stages/4/calling-methods","language":"en","stage":4,"index":3,"title":"Calling Methods","previous":"structures","next":"memory","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20static%20method%20to%20create%20an%20instance%20of%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20Using%20a%20method%20on%20the%20instance%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A","content":"Unlike functions, methods are functions associated with a specific data type:\nstatic methods — methods that belong to a type itself are called using the :: operator.\ninstance methods — methods that belong to an instance of a type are called using the . operator.\nWe will talk more on making your own methods in future chapters."},{"url":"http://localhost:15007/en/stages/4/creating-data-in-memory","language":"en","stage":4,"index":5,"title":"Creating Data In Memory","tags":["struct"],"previous":"memory","next":"tuple-like-structs","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22brain%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A","content":"When we instantiate a struct in our code our program creates the associated field data side by side in memory.\nWe instantiate by specifying all field values within StructName{'{...}'}\nStruct fields are accessed using a dot . operator.\nMemory details of our example:\nThe text inside the quotes is read only data (e.g. \"Ferris\"), therefore it is placed in the data memory region.\nThe function call String::from creates a struct String that is placed side by side with the fields of SeaCreature in the stack. A String represents text that can be changed and does this by:\nCreating memory on the heap for the text where it can be modified\nStoring a reference to that memory location on the heap and storing it in String struct (More on this in future lessons)\nFinally our two friends Ferris and Sarah have data structures that will always have fixed locations in our program, so they are placed on the stack."},{"url":"http://localhost:15007/en/stages/4/enums-with-data","language":"en","stage":4,"index":9,"title":"Enums With Data","tags":["enum"],"previous":"enums","next":"summary","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D","content":"enum elements can also have one or more data types allowing them to behave like union from C.\nWhen an enum is pattern matched using match, you can bind a variable name to each data value.\nMemory details of enum:\nAn enum data value will have a memory size equal to its largest element. This allows for all potential values to fit in the same space of memory.\nIn addition to element data types (if any), each element also has a numeric value that represents which tag it is.\nOther details:\nRust's enum is something also known as a tagged union.\nThe combining of types to make a new type is what people mean when they say Rust has algebraic types."},{"url":"http://localhost:15007/en/stages/4/","language":"en","stage":4,"index":1,"title":"Introduction","next":"structures","content":"It's time we explore beyond basic types! In this chapter we will look at the most primitive data structures in Rust, paying close attention to their representations in memory. I think you will enjoy how little Rust hides from you how things work."},{"url":"http://localhost:15007/en/stages/4/memory","language":"en","stage":4,"index":4,"title":"Memory","previous":"calling-methods","next":"creating-data-in-memory","content":"Rust programs have 3 memory regions where data is stored:\ndata memory - For data that is fixed in size and static (i.e. always available through life of program). Consider the text in your program (e.g. \"Hello World!\"): This text's bytes are only ever read from one place and therefore can be stored in this region. Compilers make lots of optimizations with this kind of data, and they are generally considered very fast to use since locations are known and fixed.\nstack memory - For data that is declared as variables within a function. The location of this memory never changes for the duration of a function call; because of this compilers can optimize code so stack data is very fast to access.\nheap memory - For data that is created while the application is running. Data in this region may be added, moved, removed, resized, etc. Because of its dynamic nature it's generally considered slower to use, but it allows for much more creative usages of memory. When data is added to this region we call it an allocation. When data is removed from this section we call it a deallocation."},{"url":"http://localhost:15007/en/stages/4/summary","language":"en","stage":4,"index":10,"title":"Summary","previous":"enums-with-data","content":"How exciting! We now have the most basic tools for representing the form of our ideas in code. Hopefully now we can see a glimmer of how Rust's fundamental operations work in harmony and conciseness with its types. Next up we will talk about a concept that gives our data types even more flexibility of representation: generics."},{"url":"http://localhost:15007/en/stages/4/tuple-like-structs","language":"en","stage":4,"index":6,"title":"Tuple-like Structs","tags":["struct"],"previous":"creating-data-in-memory","next":"unit-like-structs","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20still%20a%20struct%20on%20a%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A","content":"For conciseness, you can create structs that are used like a tuple.\nThis is a good practice to improve the readability of your code by giving the tuple a name."},{"url":"http://localhost:15007/en/stages/4/unit-like-structs","language":"en","stage":4,"index":7,"title":"Unit-like Structs","tags":["struct"],"previous":"tuple-like-structs","next":"enums","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A","content":"Structs do not have to have any fields at all.\nAs mentioned in Chapter 1 a unit is another word for an empty tuple (). This is why this kind of struct is called Unit-like.\nThis type of struct is rarely used."},{"url":"http://localhost:15007/en/stages/5/failable-main","language":"en","stage":5,"index":6,"title":"Failable Main","previous":"result","next":"error-handling","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Main%20returns%20no%20value%2C%20but%20could%20return%20an%20error!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20handle%20this%20error%20gracefully%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20return%20a%20new%20error%20from%20main%20that%20said%20what%20happened!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22something%20went%20wrong%20in%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Notice%20we%20use%20a%20unit%20value%20inside%20a%20Result%20Ok%0A%20%20%20%20%2F%2F%20to%20represent%20everything%20is%20fine%0A%20%20%20%20Ok(())%0A%7D%0A","content":"the main function has the capability of returning a Result!"},{"url":"http://localhost:15007/en/stages/5/","language":"en","stage":5,"index":1,"title":"Introduction","next":"what-are-generic-types","content":"Generic types are incredibly important in Rust. They are used in the representation of nullable values (i.e. variables which might not have a value yet), error handling, collections, and more! In this section we will be learning about the foundational generic types you will likely be using all the time."},{"url":"http://localhost:15007/en/stages/5/representing-nothing","language":"en","stage":5,"index":3,"title":"Representing Nothing","tags":["enum"],"previous":"what-are-generic-types","next":"option","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventory(String)%2C%0A%20%20%20%20%2F%2F%20None%20represents%20the%20absence%20of%20an%20item%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20BagOfHolding%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A","content":"In other languages, the keyword null is used to represent an absence of a value. It creates difficulty in programming languages because it creates the possibility that our program might fail when interacting with a variable/field.\nRust does not have null, but it is not ignorant of the importance of representing nothing! Consider a naive representation using a tool we already know.\nThis pattern of providing a None alternative representation for one or many alternate values is so common in Rust because of its lack of a null value. Generic types help solve this challenge."},{"url":"http://localhost:15007/en/stages/5/summary","language":"en","stage":5,"index":10,"title":"Summary","previous":"vectors","content":"In one chapter we've learned how much power generic types give us! Don't worry if you don't know fully how to use everything, right now it's just good to be aware of the major ideas you will see again and again in code. Our functions are getting quite lengthy! In our next chapter we will spend talk about an important concept in Rust: data ownership."},{"url":"http://localhost:15007/en/stages/5/ugly-option-result-handling","language":"en","stage":5,"index":8,"title":"Ugly Option / Result Handling","tags":["generics","enum"],"previous":"error-handling","next":"vectors","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20concise%20but%20assumptive%20and%20gets%20ugly%20fast%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20will%20panic!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(1).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A","content":"Working with Option / Result can be tedious when you are just trying to write some quick code. Both Option and Result have a function called unwrap that can be useful for getting a value in a quick and dirty manner. unwrap will:\nGet the value inside Option/Result\nIf the enum is of type None/Err, panic!\nThese two pieces of code are equivalent:\nSimilarly:\nBe a good rustacean and properly use match when you can!"},{"url":"http://localhost:15007/en/stages/6/borrowing-mutable-ownership-with-references","language":"en","stage":6,"index":8,"title":"Borrowing Mutable Ownership With References","previous":"borrowing-ownership-with-references","next":"dereferencing","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20do_something(foo)%20would%20fail%20because%0A%20%20%20%20%2F%2F%20foo%20cannot%20be%20moved%20while%20mutably%20borrowed%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20foo.x%20%3D%2013%3B%20would%20fail%20here%20because%0A%20%20%20%20%2F%2F%20foo%20is%20not%20modifiable%20while%20mutably%20borrowed%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%20because%20it's%20no%20longer%20used%20after%20this%20point%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20works%20now%20because%20all%20mutable%20references%20were%20dropped%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20move%20foo's%20ownership%20to%20a%20function%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A","content":"We can also borrow mutable access to a resource with the &mut operator.\nA resource owner cannot be moved or modified while mutably borrowed.\nMemory details:\nRust prevents having two ways to mutate an owned value because it introduces the possibility of a data race."},{"url":"http://localhost:15007/en/stages/6/borrowing-ownership-with-references","language":"en","stage":6,"index":7,"title":"Borrowing Ownership With References","previous":"returning-ownership","next":"borrowing-mutable-ownership-with-references","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A","content":"References allow us borrow access to a resource with the & operator.\nReferences are also dropped like other resources."},{"url":"http://localhost:15007/en/stages/6/dropping-is-hierarchical","language":"en","stage":6,"index":4,"title":"Dropping Is Hierarchical","previous":"scope-based-resource-management","next":"moving-ownership","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20first%0A%20%20%20%20%2F%2F%20then%20foo.bar%20is%20dropped%0A%7D%0A","content":"When a struct is dropped, the struct itself is dropped first, then its children are dropped individually, and so on.\nMemory details:\nBy automatically freeing memory Rust helps ensure that there are fewer memory leaks.\nMemory resources can only be dropped once."},{"url":"http://localhost:15007/en/stages/6/","language":"en","stage":6,"index":1,"title":"Introduction","next":"ownership","content":"Rust has a unique paradigm for managing memory compared to other programming languages. We're going to look at the behaviors and validations of the compiler one by one so it's not overwhelming. It's important to remember that ultimately the rules we show don't exist to make your life hard, but to help you make your code less error-prone!"},{"url":"http://localhost:15007/en/stages/6/lifetimes-in-data-types","language":"en","stage":6,"index":15,"title":"Lifetimes In Data Types","previous":"static-lifetimes","next":"summary","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A","content":"Similarly to functions, data types can be parameterized with lifetime specifiers of its members.\nRust validates that the containing data structure of the references never lasts longer than the owners its references point to.\nWe can't have structs running around with references pointing to nothingness!"},{"url":"http://localhost:15007/en/stages/6/multiple-lifetimes","language":"en","stage":6,"index":13,"title":"Multiple Lifetimes","previous":"explicit-lifetimes","next":"static-lifetimes","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20and%20the%20return%20value%20share%20the%20same%20lifetime%0A%2F%2F%20foo_a%20has%20an%20unrelated%20lifetime%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20only%20foo_b's%20lifetime%20exist%20beyond%20here%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%0A%7D%0A","content":"Lifetime specifiers allow us to be explicit with certain scenarios the compiler cannot resolve itself by distinguishing all of a function signature component's lifetimes."},{"url":"http://localhost:15007/en/stages/6/passing-around-borrowed-data","language":"en","stage":6,"index":10,"title":"Passing Around Borrowed Data","previous":"dereferencing","next":"references-of-references","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20mutable%20reference%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20because%20all%20mutable%20references%20are%20dropped%20within%0A%20%20%20%20%2F%2F%20the%20function%20do_something%2C%20we%20can%20create%20another.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A","content":"Rust's rules for references might best be summarized by:\nRust only allows there to be one mutable reference or multiple non-mutable references but not both.\nA reference must never live longer than its owner.\nThis doesn't tend to be a problem when passing around references to functions.\nMemory details:\nThe first rule of references prevents data races. What's a data race? A data race when reading from data has the possibility of being out of sync due to the existence of a writer to the data at the same time. This happens often in multi-threaded programming.\nThe second rule of references prevents the misuse of references that refer to non-existent data (called dangling pointers in C)."},{"url":"http://localhost:15007/en/stages/6/references-of-references","language":"en","stage":6,"index":11,"title":"References Of References","previous":"passing-around-borrowed-data","next":"explicit-lifetimes","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A","content":"References can even be used on pieces of references."},{"url":"http://localhost:15007/en/stages/6/returning-ownership","language":"en","stage":6,"index":6,"title":"Returning Ownership","previous":"moving-ownership","next":"borrowing-ownership-with-references","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20ownership%20is%20moved%20out%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20becomes%20the%20owner%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20because%20of%20end%20of%20function%20scope%0A%7D%0A","content":"Ownership can also be returned from a function."},{"url":"http://localhost:15007/en/stages/6/scope-based-resource-management","language":"en","stage":6,"index":3,"title":"Scope-based Resource Management","previous":"ownership","next":"dropping-is-hierarchical","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%20%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%0A%7D%0A","content":"Rust uses the end of scope as the place to deconstruct and deallocate a resource.\nThe term for this deconstruction and deallocation is called a drop.\nMemory details:\nRust does not have garbage collection.\nThis is also called Resource Aquisition Is Initialization ( RAII ) in C++."},{"url":"http://localhost:15007/en/stages/6/summary","language":"en","stage":6,"index":16,"title":"Summary","previous":"lifetimes-in-data-types","content":"Whew, congrats for making it through! I know it's a lot to take in, but you are well under way to becoming a Rustacean. Hopefully it's clear how Rust as a language aims to solve many of these common challenges in systems programming:\nUnintentional modification of resources\nForgetting to deconstruct resources\nResources accidentally being deconstructed twice\nUsing resources after they have been deconstructed\nData races caused by writing to resources while others are reading from resources\nSeeing clearly areas of the code where the compiler can’t make guarantees\nIn the next chapter we'll apply some of this knowledge as we look at how Rust handles text."},{"url":"http://localhost:15007/en/stages/7/building-strings","language":"en","stage":7,"index":12,"title":"Building Strings","previous":"text-as-function-parameters","next":"formatting-strings","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22hello%22%2C%20%22%20%22%2C%20%22world%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A","content":"concat and join are two simple but powerful ways for building strings."},{"url":"http://localhost:15007/en/stages/7/","language":"en","stage":7,"index":1,"title":"Introduction","next":"string-literals","content":"Now that we understand a bit how Rust thinks of memory, we are prepared to talk about text in more detail. Rust cares a great deal about international text and byte level concerns you might not be familiar with from other languages. That said, Rust has many great tools for managing those concerns."},{"url":"http://localhost:15007/en/stages/7/multi-line-string-literals","language":"en","stage":7,"index":5,"title":"Multi-line String Literals","previous":"escaping-characters","next":"raw-string-literals","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20I%20write%2C%20erase%2C%20rewrite%0A%20%20%20%20%20%20%20%20Erase%20again%2C%20and%20then%0A%20%20%20%20%20%20%20%20A%20poppy%20blooms.%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22hello%20%5C%0A%20%20%20%20world%22)%20%2F%2F%20notice%20that%20the%20spacing%20before%20world%20is%20ignored%0A%7D%0A","content":"Rust strings are multiline by default.\nUse a \\ at the end of a line if you don't want a line break."},{"url":"http://localhost:15007/en/stages/7/raw-string-literals","language":"en","stage":7,"index":6,"title":"Raw String Literals","previous":"multi-line-string-literals","next":"string-literals-from-files","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Raw%20strings%20are%20useful%20for%20some%20situations.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A","content":"Raw strings allow us to write a sequence of characters verbatim by starting with r#\" and ending with \"#. It lets us insert characters that might otherwise confuse a normal string as literals (like double quotes and backslashes)."},{"url":"http://localhost:15007/en/stages/7/string-literals","language":"en","stage":7,"index":2,"title":"String Literals","previous":"./","next":"what-is-utf-8","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A","content":"String literals are always Unicode.\nString literals type are &'static str:\n& meaning that it's referring to a place in memory, and it lacks a &mut meaning that the compiler will not allow modification\n'static meaning the string data will be available till the end of our program (it never drops)\nstr means that it points to a sequence of bytes that are always valid utf-8\nMemory details:\nThe Rust compiler will likely put your string in the data segment of your program memory"},{"url":"http://localhost:15007/en/stages/7/summary","language":"en","stage":7,"index":17,"title":"Summary","previous":"useful-string-method","content":"Now you know the basics of text! As you have seen, Unicode makes working with text a bit tricky, but the standard library has plenty of functionality to make it easy to manage.\nUp to now, we've mostly looked at Rust from the lens of a procedural paradigm (i.e. just functions and data), but it's time we now talk about traits and the capabilities unlocked by Rust's object oriented paradigm."},{"url":"http://localhost:15007/en/stages/7/text-as-function-parameters","language":"en","stage":7,"index":11,"title":"Text As Function Parameters","previous":"string","next":"building-strings","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20borrow%20%26'static%20str%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%22hello%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20also%20borrow%20String%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22goodbye%22))%3B%0A%7D%0A","content":"String literals and strings are generally passed around as a string slice to functions. This offers a lot of flexibility for most scenarios where you don't actually have to pass ownership."},{"url":"http://localhost:15007/en/stages/8/encapsulation-with-methods","language":"en","stage":8,"index":4,"title":"Encapsulation With Methods","previous":"rust-is-not-oop","next":"abstraction-with-selective-exposure","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20creature.get_sound())%3B%0A%7D%0A","content":"Rust supports the concept of an object that is a struct associated with some functions (also known as methods).\nThe first parameter of any method must be a reference to the instance associated with the method call (e.g. instanceOfObj.foo()). Rust uses:\n&self - Immutable reference to the instance.\n&mut self - Mutable reference to the instance.\nMethods are defined within an implementation block with keyword impl:"},{"url":"http://localhost:15007/en/stages/8/generic-functions-shorthand","language":"en","stage":8,"index":13,"title":"Generic Functions Shorthand","previous":"generic-functions-shorthand","next":"box","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise(creature%3A%20%26impl%20NoiseMaker)%0A%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%20at%20compile-time%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A","content":"Rust has a shorthand for expressing generics constrained by a trait:\nThis is equivalent to writing:"},{"url":"http://localhost:15007/en/stages/8/generic-structs-revisited","language":"en","stage":8,"index":15,"title":"Generic Structs Revisited","tags":["generics","struct"],"previous":"box","next":"summary","content":"Generic structs can also have their parameterized types constrained by traits:\nGeneric structs have their parameterized type in their implementation blocks:"},{"url":"http://localhost:15007/en/stages/8/","language":"en","stage":8,"index":1,"title":"Introduction","next":"what-is-object-oriented-programming","content":"Expressing ideas with functions is a proven way of representing behavior and data (C has been doing it for decades!). Historically, computer science has found other useful expressive aggregations and abstractions for data. You may be familiar with object oriented programming (OOP) as one such way. In this chapter we'll explore the Rust programming language beyond functions."},{"url":"http://localhost:15007/en/stages/8/polymorphism-with-traits","language":"en","stage":8,"index":6,"title":"Polymorphism With Traits","previous":"abstraction-with-selective-exposure","next":"implemented-methods-on-traits","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A","content":"Rust supports polymorphism with traits. Traits allow us to associate a set of methods with a struct type.\nWe first define the signatures of methods of a trait within:\nWhen a struct implements a trait, it establishes a contract that allows us to indirectly interact with the struct through the trait type (e.g. &dyn MyTrait) without having to know the real type.\nA struct's implemented traits methods are defined within an implementation block:"},{"url":"http://localhost:15007/en/stages/8/rust-is-not-oop","language":"en","stage":8,"index":3,"title":"Rust Is Not OOP","previous":"what-is-object-oriented-programming","next":"encapsulation-with-methods","content":"Rust lacks inheritance of data and behavior in any meaningful way:\nStructs cannot inherit fields from a parent struct.\nStructs cannot inherit functions from a parent struct.\nThat said, Rust implements many programming language features, so that you might not mind this lacking."},{"url":"http://localhost:15007/en/stages/8/summary","language":"en","stage":8,"index":16,"title":"Summary","previous":"generic-structs-revisited","content":"We now have more language features at hand to represent our ideas clearly! Rust abstractions might be simple but they are powerful enough to make working with code a joy. In this chapter, we caught a glimpse of smart pointers with Box. In the next chapter we'll learn about how smart pointers can help us with other specialized memory situations."},{"url":"http://localhost:15007/en/stages/8/trait-inheritance","language":"en","stage":8,"index":8,"title":"Trait Inheritance","previous":"implemented-methods-on-traits","next":"dynamic-vs-static-dispatch","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Atrait%20LoudNoiseMaker%3A%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20LoudNoiseMaker%20for%20SeaCreature%20%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A","content":"Traits can inherit methods from other traits."},{"url":"http://localhost:15007/en/stages/8/what-is-object-oriented-programming","language":"en","stage":8,"index":2,"title":"What Is Object Oriented Programming (OOP)?","previous":"./","next":"rust-is-not-oop","content":"Object oriented programming roughly refers to programming languages that have a number of iconic features:\nEncapsulation - Associating data and functions into the conceptual unit of a single type called an object.\nAbstraction - Hiding data and function members to obfuscate implementation details of an object.\nPolymorphism - The ability to interact with objects of different types through one interface.\nInheritance - The ability to inherit data and behavior from other objects."},{"url":"http://localhost:15007/en/stages/9/combining-smart-pointers","language":"en","stage":9,"index":15,"title":"Combining Smart Pointers","previous":"sharing-across-threads","next":"summary","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20took%20a%20slice!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20use%20smart%20pointer%20to%20pie%20for%20a%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20take%20a%20bite!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20ferris%20and%20sarah%20are%20given%20clones%20of%20smart%20pointer%20to%20pie%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22sarah%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2C%20p.slices)%3B%0A%7D%0A","content":"Smart pointers might seem limited, but they can make some very powerful combinations.\n{'Rc<Vec> '} - Allow the cloning of multiple smart pointers that can borrow the same vector of immutable data structures on the heap. {'Rc<RefCell>'} - Allow multiple smart pointers the ability to borrow mutably/immutably the same struct Foo {'Arc<Mutex>'} - Allow multiple smart pointers the ability to lock temporary mutable/immutable borrows in a CPU thread exclusive manner.\nMemory details:\nYou'll notice a theme with many of these combinations. The use of a immutable data type (possibly owned by multiple smart pointers) to modify internal data. This is referred to as the \"interior mutability\" pattern in Rust. It is a pattern that lets us bend the rules of memory usage at runtime with the same level of safety as Rust's compile-time checks."},{"url":"http://localhost:15007/en/stages/9/failable-main-revisited","language":"en","stage":9,"index":11,"title":"Failable Main Revisited","previous":"heap-allocated-memory","next":"referencing-counting","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20core%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C'_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22This%20pie%20is%20not%20fresh!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A","content":"Rust code may have a plethora of representations of errors, but the standard library has a universal trait std::error::Error for describing errors.\nUsing a smart pointer Box we can use the type {'Box'} as a common type for returning errors because it allows us to propagate up an error on the heap and interact with it at a high level without having to know a specific type.\nEarly in Rust Jungle we learned that the main function can return an error. We can now return a type capable of describing almost any kind of error that might occur in our program so long as the error's data structure implements Rust's common Error trait.\n{'fn main() -> Result<(), Box>'}"},{"url":"http://localhost:15007/en/stages/9/familiar-friends","language":"en","stage":9,"index":9,"title":"Familiar Friends","previous":"smart-unsafe-code","next":"heap-allocated-memory","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20let's%20ask%20for%204%20bytes%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20allocate%20and%20save%20the%20memory%20location%20as%20a%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20pointer%20math%20and%20write%20a%20few%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20u8%20values%20to%20memory%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20interpret%20secret_recipe%20pointer%20as%20a%20f32%20raw%20pointer%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it%20into%20a%20return%20value%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22make%20a%20pie%22%20by%20dereferencing%20our%20%0A%20%20%20%20%2F%2F%20Pie%20struct%20smart%20pointer%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A","content":"Consider some smart pointers we've already seen like {'Vec'} and String. {'Vec'} is a smart pointer that just owns some memory region of bytes. The Rust compiler has no idea what exists in these bytes. The smart pointer interprets what it means to grab items from the region of memory it manages, keeps track of where data structures within those bytes begin and end, and then finally dereferences a raw pointer into data structures into a nice clean ergonomic interface for us to use (e.g. my_vec[3]).\nSimilarly, String keeps track of a memory region of bytes, and programmatically restricts content written to it to always be valid UTF-8 and helps dereference that memory region into a type &str.\nBoth these datastructures use unsafe dereferencing of raw pointers to do their job.\nMemory details:\nRust has an equivalent of C's malloc using alloc and Layout for getting ahold of your own memory regions to manage."},{"url":"http://localhost:15007/en/stages/9/heap-allocated-memory","language":"en","stage":9,"index":10,"title":"Heap Allocated Memory","previous":"familiar-friends","next":"failable-main-revisited","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A","content":"Box is a smart pointer that lets us move data from the stack to the heap.\nDereferencing it lets us use the heap allocated data ergonomically as if it were the original type."},{"url":"http://localhost:15007/en/stages/9/","language":"en","stage":9,"index":1,"title":"Introduction","next":"references-revisited","content":"In this chapter we will demystify smart pointers. Let's explore into these data structures that let us interact with the lowest level of memory.\nFerris says: \"Don't feel overwhelmed by this chapter if you don't feel you can write your own low level memory management code in one short read. This chapter is mostly to introduce you to some useful tools and give a glimpse at how they work!\""},{"url":"http://localhost:15007/en/stages/9/references-revisited","language":"en","stage":9,"index":2,"title":"References Revisited","previous":"./","next":"raw-pointers","content":"A reference is fundamentally just a number that is the start position of some bytes in memory. Its only purpose is to represent the concept of where data of a specific type exists. What makes a reference different from just a number is that Rust will validate the lifetime of references doesn't last longer than what it refers to (otherwise we'd get an error when we used it!)."},{"url":"http://localhost:15007/en/stages/9/summary","language":"en","stage":9,"index":16,"title":"Summary","previous":"combining-smart-pointers","content":"Smart pointers are the idioms of Rust programming and let us not have to re-create the very common patterns of memory usage. With them you are ready to tackle the toughest of challenges! Now that we have the foundations of Rust, let's talk a bit about how we make larger projects. In chapter 9 we break free of single page lines of code."},{"url":"http://localhost:15007/en/stages/9/the-dereference-operator","language":"en","stage":9,"index":5,"title":"The Dereference Operator *","previous":"references-revisited","next":"the-dot-operator","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20i32%20%3D%2042%3B%0A%20%20%20%20let%20ref_ref_ref_a%3A%20%26%26%26i32%20%3D%20%26%26%26a%3B%0A%20%20%20%20let%20ref_a%3A%20%26i32%20%3D%20**ref_ref_ref_a%3B%0A%20%20%20%20let%20b%3A%20i32%20%3D%20*ref_a%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20b)%0A%7D","content":"The * operator is an explicit way to dereference a reference.\nMemory details:\nBecause i32 is a primitive type that implements the Copy trait, the bytes of variable a on stack are copied into the bytes of variable b."},{"url":"http://localhost:15007/en/stages/9/the-dot-operator","language":"en","stage":9,"index":6,"title":"The Dot Operator .","previous":"the-dereference-operator","next":"smart-pointers","playground":"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20value%3A%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20f%20%3D%20Foo%20%7B%20value%3A%2042%20%7D%3B%0A%20%20%20%20let%20ref_f%20%3D%20%26f%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20ref_f.value)%3B%0A%7D","content":"The . operator is used in accessing fields and methods of a reference. It works a bit more subtly.\nWhoa, why didn't we need to add * before ref_f? This is because the . operator automatically dereferences a sequence of references."}]}