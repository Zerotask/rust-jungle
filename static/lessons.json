{"tags":["arrays","data-types","variables","compiler","functions","macros","program","cargo","testing","iteration","struct","enum","error-handling","generics","macro"],"stages":{"1":"The Basics","2":"Rust installation and local development","3":"Basic Control Flow","4":"Basic Data Structure Types","5":"Generic Types","6":"Ownership & Borrowing Data","7":"Text","8":"Object Oriented Programming (OOP)","9":"Smart Pointers","10":"Project Organization and Stucture"},"lessons":[{"url":"http://localhost:15007/en/stages/1/","language":"en","stage":1,"index":1,"title":"Introduction - The Basics","next":"the-rust-playground","content":"In the first stage we're going to be exploring the very basics with functions, variables, and the most primitive types. Glad to have you on board!\nAlso! In case you are wondering who this adorable crab who is speaking to you is, I am Ferris, the unofficial mascot for the Rust programming language. Nice to meet you.\nOnce you get familiar with Rust, you can call yourself a Rustacean. That's how people who use, contribute or are interested in Rust call themself.\nSome lessons will provide further information from the following official sources:\nRust Book\nRust by Example\nthe docs website (docs.rs)"},{"url":"http://localhost:15007/en/stages/10/","language":"en","stage":10,"index":1,"title":"Introduction - Project Organization and Stucture","next":"modules","content":"So far all of our code examples have been a single file. Let's discuss how our code can be better organized and shared by others!"},{"url":"http://localhost:15007/en/stages/2/","language":"en","stage":2,"index":1,"title":"Introduction - Rust installation and local development","next":"installation","content":"In this stage you will learn how to install Rust locally and you will learn about some important Rust tools like rustup (the Rust toolchain installer) and cargo (Rust's package manager).\nYou will also learn how to write and test your own Rust programs with Visual Studio Code."},{"url":"http://localhost:15007/en/stages/3/","language":"en","stage":3,"index":1,"title":"Introduction - Basic Control Flow","next":"if-else","content":"In this chapter let's talk about basic control flow methods in Rust. If you are familiar with C based languages you'll feel right at home and maybe enjoy a surprise or two."},{"url":"http://localhost:15007/en/stages/4/","language":"en","stage":4,"index":1,"title":"Introduction - Basic Data Structure Types","next":"structures","content":"It's time we explore beyond basic types! In this chapter we will look at the most primitive data structures in Rust, paying close attention to their representations in memory. I think you will enjoy how little Rust hides from you how things work."},{"url":"http://localhost:15007/en/stages/5/","language":"en","stage":5,"index":1,"title":"Introduction - Generic Types","next":"what-are-generic-types","content":"Generic types are incredibly important in Rust. They are used in the representation of nullable values (i.e. variables which might not have a value yet), error handling, collections, and more! In this section we will be learning about the foundational generic types you will likely be using all the time."},{"url":"http://localhost:15007/en/stages/6/","language":"en","stage":6,"index":1,"title":"Introduction - Ownership & Borrowing Data","next":"ownership","content":"Rust has a unique paradigm for managing memory compared to other programming languages. We're going to look at the behaviors and validations of the compiler one by one so it's not overwhelming. It's important to remember that ultimately the rules we show don't exist to make your life hard, but to help you make your code less error-prone!"},{"url":"http://localhost:15007/en/stages/7/","language":"en","stage":7,"index":1,"title":"Introduction - Text","next":"string-literals","content":"Now that we understand a bit how Rust thinks of memory, we are prepared to talk about text in more detail. Rust cares a great deal about international text and byte level concerns you might not be familiar with from other languages. That said, Rust has many great tools for managing those concerns."},{"url":"http://localhost:15007/en/stages/8/","language":"en","stage":8,"index":1,"title":"Introduction - Object Oriented Programming (OOP)","next":"what-is-object-oriented-programming","content":"Expressing ideas with functions is a proven way of representing behavior and data (C has been doing it for decades!). Historically, computer science has found other useful expressive aggregations and abstractions for data. You may be familiar with object oriented programming (OOP) as one such way. In this chapter we'll explore the Rust programming language beyond functions."},{"url":"http://localhost:15007/en/stages/9/","language":"en","stage":9,"index":1,"title":"Introduction - Smart Pointers","next":"references-revisited","content":"In this chapter we will demystify smart pointers. Let's explore into these data structures that let us interact with the lowest level of memory.\nFerris says: \"Don't feel overwhelmed by this chapter if you don't feel you can write your own low level memory management code in one short read. This chapter is mostly to introduce you to some useful tools and give a glimpse at how they work!\""},{"url":"http://localhost:15007/en/stages/1/the-rust-playground","language":"en","stage":1,"index":2,"title":"The Rust Playground","previous":"./","next":"variables","content":"Rust Jungle uses an interactive coding tool from Rust Playground.\nIt's a great way to play around with Rust and show others your creativity and challenges!\nBesides the Rust Playground we use a code highlighting for Rust language specific parts in the text and italic for other special words or phrases.\nAfter you learned the very basics, you will learn in stage 2 how to develop with Rust locally."},{"url":"http://localhost:15007/en/stages/10/modules","language":"en","stage":10,"index":2,"title":"Modules","previous":"./","next":"writing-a-program","content":"Every Rust program or library is a crate.\nEvery crate is made of a hierarchy of modules.\nEvery crate has a root module.\nA module can hold global variables, functions, structs, traits or even other modules!\nIn Rust there is not a 1 to 1 mapping of files to the module tree hierarchy. We must build the module tree explicitly by hand in our code."},{"url":"http://localhost:15007/en/stages/2/installation","language":"en","stage":2,"index":2,"title":"Installation","previous":"./","next":"rustup","content":"The recommended way to install Rust and its tools is to download rustup, Rust's toolchain manager.\nYou can download it here: https://www.rust-lang.org/tools/install (RUSTUP-INIT)\nAfter the installation you can run rustc --version (Rust's compiler) to check, if it's installed properly."},{"url":"http://localhost:15007/en/stages/3/if-else","language":"en","stage":3,"index":2,"title":"if / else","previous":"./","next":"loop","content":"In this chapter let's talk about basic control flow methods in Rust. If you are familiar with C based languages you'll feel right at home and maybe enjoy a surprise or two.\nConditions don't have parentheses! Did we ever really need them? Our logic now looks nice and clean.\nAll your usual relational and logical operators still work: ==, !=, {'<'}, {'>'}, {'<='}, {'>='}, !, ||, &&."},{"url":"http://localhost:15007/en/stages/4/structures","language":"en","stage":4,"index":2,"title":"Structures","tags":["struct"],"previous":"./","next":"calling-methods","content":"A struct is a collection of fields.\nA field is simply a data value associated with a data structure. Its value can be of a primitive type or a data structure.\nIts definition is like a blueprint for a compiler on how to layout the fields in memory nearby each other."},{"url":"http://localhost:15007/en/stages/5/what-are-generic-types","language":"en","stage":5,"index":2,"title":"What Are Generic Types?","tags":["generics"],"previous":"./","next":"representing-nothing","content":"Generic types allow us to partially define a struct or enum, enabling a compiler to create a fully defined version at compile-time based off our code usage.\nRust generally can infer the final type by looking at our instantiation, but if it needs help you can always be explicit using the {'::'} operator, also known by the name turbofish (he's a good friend of mine!)."},{"url":"http://localhost:15007/en/stages/6/ownership","language":"en","stage":6,"index":2,"title":"Ownership","previous":"./","next":"scope-based-resource-management","content":"Instantiating a type and binding it to a variable name creates a memory resource that the Rust compiler will validate through its whole lifetime. The bound variable is called the resource's owner.\nOwnership is a very unique feature and the reason for Rust's memory safety."},{"url":"http://localhost:15007/en/stages/7/string-literals","language":"en","stage":7,"index":2,"title":"String Literals","previous":"./","next":"what-is-utf-8","content":"String literals are always Unicode.\nString literals type are &'static str:\n& meaning that it's referring to a place in memory, and it lacks a &mut meaning that the compiler will not allow modification\n'static meaning the string data will be available till the end of our program (it never drops)\nstr means that it points to a sequence of bytes that are always valid utf-8\nMemory details:\nThe Rust compiler will likely put your string in the data segment of your program memory"},{"url":"http://localhost:15007/en/stages/8/what-is-object-oriented-programming","language":"en","stage":8,"index":2,"title":"What Is Object Oriented Programming (OOP)?","previous":"./","next":"rust-is-not-oop","content":"Object oriented programming roughly refers to programming languages that have a number of iconic features:\nEncapsulation - Associating data and functions into the conceptual unit of a single type called an object.\nAbstraction - Hiding data and function members to obfuscate implementation details of an object.\nPolymorphism - The ability to interact with objects of different types through one interface.\nInheritance - The ability to inherit data and behavior from other objects."},{"url":"http://localhost:15007/en/stages/9/references-revisited","language":"en","stage":9,"index":2,"title":"References Revisited","previous":"./","next":"raw-pointers","content":"A reference is fundamentally just a number that is the start position of some bytes in memory. Its only purpose is to represent the concept of where data of a specific type exists. What makes a reference different from just a number is that Rust will validate the lifetime of references doesn't last longer than what it refers to (otherwise we'd get an error when we used it!)."},{"url":"http://localhost:15007/en/stages/1/variables","language":"en","stage":1,"index":3,"title":"Variables","previous":"the-rust-playground","next":"changing-variables","content":"Variables are declared using the let keyword.\nWhen assigning a value, Rust will be able to infer the type of your variable 99% of the time. If it cannot you may add the type to your variable declaration.\nNotice how we can assign to the same variable name multiple times. This is called variable shadowing and the type can be changed for subsequent references to that name.\nVariable names are always in snake_case."},{"url":"http://localhost:15007/en/stages/10/writing-a-program","language":"en","stage":10,"index":3,"title":"Writing A Program","tags":["program"],"previous":"modules","next":"writing-a-library","content":"A program has a root module in a file called main.rs.\nYou can use cargo to create a new program, e. g. cargo new my-program.\nThis will create a src/main.rs file for you."},{"url":"http://localhost:15007/en/stages/2/rustup","language":"en","stage":2,"index":3,"title":"rustup","previous":"installation","next":"cargo","content":"rustup is Rust's toolchain manager. To see all available options of this tool, run rustup --help.\nIt's used for:\nupdating Rust: rustup update\ninstalling Rust tools like Clippy (a static analysis tool): rustup component add clippy - you can run it then with cargo clippy\nOpen the official The book: rustup doc --book\nShow active and installed tools: rustup show\nSwitching between profiles, e. g. stable and nightly version of Rust\nrustup can be updated with rustup self update, but it's also being updated at the end of rustup update."},{"url":"http://localhost:15007/en/stages/3/loop","language":"en","stage":3,"index":3,"title":"loop","tags":["iteration"],"previous":"if-else","next":"returning-values-from-loop","content":"Need an infinite loop? Rust makes it easy.\nbreak will escape a loop when you are ready.\nloop has a secret we'll talk about soon."},{"url":"http://localhost:15007/en/stages/4/calling-methods","language":"en","stage":4,"index":3,"title":"Calling Methods","previous":"structures","next":"memory","content":"Unlike functions, methods are functions associated with a specific data type:\nstatic methods — methods that belong to a type itself are called using the :: operator.\ninstance methods — methods that belong to an instance of a type are called using the . operator.\nWe will talk more on making your own methods in future chapters."},{"url":"http://localhost:15007/en/stages/5/representing-nothing","language":"en","stage":5,"index":3,"title":"Representing Nothing","tags":["enum"],"previous":"what-are-generic-types","next":"option","content":"In other languages, the keyword null is used to represent an absence of a value. It creates difficulty in programming languages because it creates the possibility that our program might fail when interacting with a variable/field.\nRust does not have null, but it is not ignorant of the importance of representing nothing! Consider a naive representation using a tool we already know.\nThis pattern of providing a None alternative representation for one or many alternate values is so common in Rust because of its lack of a null value. Generic types help solve this challenge."},{"url":"http://localhost:15007/en/stages/6/scope-based-resource-management","language":"en","stage":6,"index":3,"title":"Scope-based Resource Management","previous":"ownership","next":"dropping-is-hierarchical","content":"Rust uses the end of scope as the place to deconstruct and deallocate a resource.\nThe term for this deconstruction and deallocation is called a drop.\nMemory details:\nRust does not have garbage collection.\nThis is also called Resource Aquisition Is Initialization ( RAII ) in C++."},{"url":"http://localhost:15007/en/stages/7/what-is-utf-8","language":"en","stage":7,"index":3,"title":"What Is UTF-8?","previous":"string-literals","next":"escaping-characters","content":"As more languages were used on computers, the world needed to represent more text characters than ASCII allowed (1 byte only allowed 256 characters).\nutf-8 was introduced with a variable byte length of 1-4 bytes greatly increasing the range of possible characters.\nAn advantage of variable sized characters is text did not have unnecessary bytes for very common ASCII (only requiring 1 byte still in utf-8).\nA downside of variable sized characters is that character lookup can no longer be done quickly (O(1) constant time) with a simple indexing (e.g. my_text[3] to get the 4th character). It's possible that the preceding characters could have variable widths, altering where the 4th character actually begins in the sequence of bytes.\nInstead we must iterate through a utf-8 byte sequence to understand where the Unicode characters actually begin (O(n) linear time).\nFerris: \"I'm mostly just happy to have utf-8 for representing emojis of my underwater friends.\"\n🐠🐙🐟🐬🐋"},{"url":"http://localhost:15007/en/stages/8/rust-is-not-oop","language":"en","stage":8,"index":3,"title":"Rust Is Not OOP","previous":"what-is-object-oriented-programming","next":"encapsulation-with-methods","content":"Rust lacks inheritance of data and behavior in any meaningful way:\nStructs cannot inherit fields from a parent struct.\nStructs cannot inherit functions from a parent struct.\nThat said, Rust implements many programming language features, so that you might not mind this lacking."},{"url":"http://localhost:15007/en/stages/9/raw-pointers","language":"en","stage":9,"index":3,"title":"Raw Pointers","previous":"references-revisited","next":"dereferencing-revisited","content":"References can be converted into a more primitive type called a raw pointer. Much like a number, it can be copied and moved around with little restriction. Rust makes no assurances of the validity of the memory location it points to.\nTwo kinds of raw pointers exist:\n*const T - A raw pointer to data of type T that should never change.\n*mut T - A raw pointer to data of type T that can change.\nRaw pointers can be converted to and from numbers (e.g. usize).\nRaw pointers can access data with unsafe code (more on this later).\nMemory details:\nA reference in Rust is very similar to a pointer in C in terms of usage, but with much more compile time restrictions on how it can be stored and moved around to other functions.\nA raw pointer in Rust is similar to a pointer in C that it represents a number that can be copied or passed around, and even turned into numerical types where it can be modifed as a number to do pointer math."},{"url":"http://localhost:15007/en/stages/1/changing-variables","language":"en","stage":1,"index":4,"title":"Changing Variables","tags":["variables"],"previous":"variables","next":"basic-types","content":"Rust cares a great deal about what variables are modifiable. Values fall into two types:\nmutable - the compiler will allow the variable to be written to and read from.\nimmutable - the compiler will only allow the variable to be read from.\nMutable values are denoted with a mut keyword.\nWe will have more to say on this concept later, but for now just keep an eye out for this keyword."},{"url":"http://localhost:15007/en/stages/10/writing-a-library","language":"en","stage":10,"index":4,"title":"Writing A Library","previous":"writing-a-program","next":"referencing-other-modules-and-crates","content":"A library has a root module in a file called lib.rs.\nYou can use cargo to create a new libray if you append the --lib flag, e. g. cargo new my-library --lib.\nThis will create a src/lib.rs file for you."},{"url":"http://localhost:15007/en/stages/2/cargo","language":"en","stage":2,"index":4,"title":"cargo","tags":["cargo"],"previous":"rustup","next":"managing-dependencies-with-cargo","content":"cargo is Rust's official package manager. If you've installed Rust with rustup, then cargo is already installed. You can verify that by running cargo --version\nTo see all available options you have with cargo, simply run: cargo --help\ncargo is used for\nCreating new projects with:\ncargo new my-project - This will create a new folder my-project with a basic setup.\ncargo init - this will create a new setup in the current folder.\nCompile your code:\ncargo build - creates a new debug build.\ncargo build --release - creates an optimized build for production.\nAlternatively you can do compiler checks without compilation with cargo check\nDuring development you can also compile and execute it directly with cargo run\nTo get a documentation of your code and all your used dependencies, simly run: cargo doc --open\nTo run tests, just execute cargo test\nFormatting your code? No problem with cargo fmt\nand many more\nIn the next lesson you will learn how to deal with dependencies in Rust using cargo."},{"url":"http://localhost:15007/en/stages/3/returning-values-from-loop","language":"en","stage":3,"index":4,"title":"Returning Values From Loop","tags":["iteration"],"previous":"loop","next":"while","content":"loop can break to return a value. This is used to assign a value to a variable."},{"url":"http://localhost:15007/en/stages/4/memory","language":"en","stage":4,"index":4,"title":"Memory","previous":"calling-methods","next":"creating-data-in-memory","content":"Rust programs have 3 memory regions where data is stored:\ndata memory - For data that is fixed in size and static (i.e. always available through life of program). Consider the text in your program (e.g. \"Hello World!\"): This text's bytes are only ever read from one place and therefore can be stored in this region. Compilers make lots of optimizations with this kind of data, and they are generally considered very fast to use since locations are known and fixed.\nstack memory - For data that is declared as variables within a function. The location of this memory never changes for the duration of a function call; because of this compilers can optimize code so stack data is very fast to access.\nheap memory - For data that is created while the application is running. Data in this region may be added, moved, removed, resized, etc. Because of its dynamic nature it's generally considered slower to use, but it allows for much more creative usages of memory. When data is added to this region we call it an allocation. When data is removed from this section we call it a deallocation."},{"url":"http://localhost:15007/en/stages/5/option","language":"en","stage":5,"index":4,"title":"Option","tags":["generics","enum"],"previous":"representing-nothing","next":"result","content":"Rust has a built in generic enum called {'Option'} that allows us to represent nullable values without using null. {'Option'} has the 2 values None and Some(T)\nThis enum is so common, instances of the enum can be created anywhere with the enum variants Some and None."},{"url":"http://localhost:15007/en/stages/6/dropping-is-hierarchical","language":"en","stage":6,"index":4,"title":"Dropping Is Hierarchical","previous":"scope-based-resource-management","next":"moving-ownership","content":"When a struct is dropped, the struct itself is dropped first, then its children are dropped individually, and so on.\nMemory details:\nBy automatically freeing memory Rust helps ensure that there are fewer memory leaks.\nMemory resources can only be dropped once."},{"url":"http://localhost:15007/en/stages/7/escaping-characters","language":"en","stage":7,"index":4,"title":"Escaping Characters","previous":"what-is-utf-8","next":"multi-line-string-literals","content":"It's challenging to visually represent certain characters, so escape codes allow us to put a symbol in their place.\nRust supports the common escape codes from C-based languages:\n\\n - newline\n\\r - carriage return\n\\t - tab\n\\\\ - backslash\n\\0 - null\n\\' - single quote"},{"url":"http://localhost:15007/en/stages/8/encapsulation-with-methods","language":"en","stage":8,"index":4,"title":"Encapsulation With Methods","previous":"rust-is-not-oop","next":"abstraction-with-selective-exposure","content":"Rust supports the concept of an object that is a struct associated with some functions (also known as methods).\nThe first parameter of any method must be a reference to the instance associated with the method call (e.g. instanceOfObj.foo()). Rust uses:\n&self - Immutable reference to the instance.\n&mut self - Mutable reference to the instance.\nMethods are defined within an implementation block with keyword impl:"},{"url":"http://localhost:15007/en/stages/9/dereferencing-revisited","language":"en","stage":9,"index":4,"title":"Dereferencing Revisited","previous":"raw-pointers","next":"the-dereference-operator","content":"The process of accessing / manipulating data that is being referred to by a reference (i.e. &i32) is called dereferencing.\nReferences are used to access/manipulate data in two ways:\nAccess to the referred data during assignment of variables.\nAccess to fields or methods of the referred data.\nRust has some powerful operators that allow us to do this."},{"url":"http://localhost:15007/en/stages/1/basic-types","language":"en","stage":1,"index":5,"title":"Basic Types","tags":["data-types"],"previous":"changing-variables","next":"basic-type-conversion","content":"Rust has a variety of familiar types:\nbooleans - bool for representing true/false\nunsigned integers - u8 u16 u32 u64 u128 for representing nonnegative whole numbers\nsigned integers - i8 i16 i32 i64 i128 for representing whole numbers\npointer sized integers - usize isize for representing indexes and sizes of things in memory\nfloating point - f32 f64\ntuple - (value, value, ...) for passing fixed sequences of values on the stack\narrays - [value, value, ...] a collection of similar elements with fixed length known at compile time\nslices - a collection of similar elements with length known at runtime\nstr(string slice) - text with a length known at runtime\nText might be more complex than you are used to in other languages; since Rust is a system programming language, it cares about memory issues you might not be used to. We will be going into this in detail later.\nNumeric types can be explicitly specified by appending the type to the end of the number (e.g. 13u32, 2u8)."},{"url":"http://localhost:15007/en/stages/10/referencing-other-modules-and-crates","language":"en","stage":10,"index":5,"title":"Referencing Other Modules And Crates","previous":"writing-a-library","next":"referencing-multiple-items","content":"Items in modules can be referenced with their full module path std::f64::consts::PI.\nA simpler way is the use keyword. It allows us to specify particular items from modules we want to use throughout our code without a full path. For instance use std::f64::consts::PI allows me to just use the identifier PI in my main function.\nstd is the crate of the standard library of Rust which is full of useful data structures and functions for interacting with your operating system.\nA searchable directory of crates created by the community can be found at ."},{"url":"http://localhost:15007/en/stages/2/managing-dependencies-with-cargo","language":"en","stage":2,"index":5,"title":"Managing Dependencies With Cargo","tags":["cargo"],"previous":"cargo","next":"cargo-subcommands","content":"At first, you have to create a workspace (project) with either cargo new my-project or cargo init.\nThis will create a Cargo.toml file in the root folder. This is your centralized configuration file for your Rust program. Within that file you can pass meta data like author or a version and it's also used to manage the dependencies for your program.\nUnlike other package manager (like npm for example) there is no CLI command to handle dependencies. In Rust you have to add it to Cargo.toml and the compiler will take care of them.\nThis will add the 3 dependencies git2, webbrowser and zip to your project. The next time you compile your program, those dependencies will get downloaded and compiled.\nTo search for packages, or crates how Rust calls it, you can:\nrun cargo search crate-name\nopen the Rust community’s crate registry:\nopen the unofficial crates.io alternative which offers categories for crates:\nTo update your dependencies, you simply run: cargo update\nIn the next lesson you will learn how to add cargo subcommands (sometimes called Rust binarier)."},{"url":"http://localhost:15007/en/stages/3/while","language":"en","stage":3,"index":5,"title":"while","tags":["iteration"],"previous":"returning-values-from-loop","next":"for","content":"while lets you easily add a condition to a loop.\nIf the condition evaluates to false, the loop will exit.\nLike the for expression, we can also use break to leave it or continue to skip the current iteration and start with the next iteration."},{"url":"http://localhost:15007/en/stages/4/creating-data-in-memory","language":"en","stage":4,"index":5,"title":"Creating Data In Memory","tags":["struct"],"previous":"memory","next":"tuple-like-structs","content":"When we instantiate a struct in our code our program creates the associated field data side by side in memory.\nWe instantiate by specifying all field values within StructName{'{...}'}\nStruct fields are accessed using a dot . operator.\nMemory details of our example:\nThe text inside the quotes is read only data (e.g. \"Ferris\"), therefore it is placed in the data memory region.\nThe function call String::from creates a struct String that is placed side by side with the fields of SeaCreature in the stack. A String represents text that can be changed and does this by:\nCreating memory on the heap for the text where it can be modified\nStoring a reference to that memory location on the heap and storing it in String struct (More on this in future lessons)\nFinally our two friends Ferris and Sarah have data structures that will always have fixed locations in our program, so they are placed on the stack."},{"url":"http://localhost:15007/en/stages/5/result","language":"en","stage":5,"index":5,"title":"Result","tags":["generics","enum"],"previous":"option","next":"failable-main","content":"Rust has a built in generic enum called {'Result<T, E>'} that allows us to return a value that has the possibility of failing. It is the idiomatic way in which the language does error handling.\nNote that our generics type has multiple parameterized types separated by a comma.\nThis enum is so common, instances of the enum can be created anywhere with the enum variants Ok and Err."},{"url":"http://localhost:15007/en/stages/6/moving-ownership","language":"en","stage":6,"index":5,"title":"Moving Ownership","previous":"dropping-is-hierarchical","next":"returning-ownership","content":"When an owner is passed as an argument to a function, ownership is moved to the function parameter.\nAfter a move the variable in the original function can no longer be used.\nMemory details:\nDuring a move the stack memory of the owners value is copied to the function call's parameter stack memory."},{"url":"http://localhost:15007/en/stages/7/multi-line-string-literals","language":"en","stage":7,"index":5,"title":"Multi-line String Literals","previous":"escaping-characters","next":"raw-string-literals","content":"Rust strings are multiline by default.\nUse a \\ at the end of a line if you don't want a line break."},{"url":"http://localhost:15007/en/stages/8/abstraction-with-selective-exposure","language":"en","stage":8,"index":5,"title":"Abstraction With Selective Exposure","previous":"encapsulation-with-methods","next":"polymorphism-with-traits","content":"Rust can hide the inner workings of objects.\nBy default fields and methods are accessible only to the module they belong to.\nThe pub keyword exposes struct fields and methods outside of the module."},{"url":"http://localhost:15007/en/stages/9/the-dereference-operator","language":"en","stage":9,"index":5,"title":"The Dereference Operator *","previous":"references-revisited","next":"the-dot-operator","content":"The * operator is an explicit way to dereference a reference.\nMemory details:\nBecause i32 is a primitive type that implements the Copy trait, the bytes of variable a on stack are copied into the bytes of variable b."},{"url":"http://localhost:15007/en/stages/1/basic-type-conversion","language":"en","stage":1,"index":6,"title":"Basic Type Conversion","tags":["data-types"],"previous":"basic-types","next":"constants","content":"Rust requires explicitness when it comes to numeric types. One cannot use a u8 for a u32 casually without error.\nLuckily Rust makes numeric type conversions very easy with the as keyword."},{"url":"http://localhost:15007/en/stages/10/referencing-multiple-items","language":"en","stage":10,"index":6,"title":"Referencing Multiple Items","previous":"referencing-other-modules-and-crates","next":"creating-modules","content":"Multiple items can be referenced in a single module path as so:\n{'use std::f64::consts::{PI,TAU}'}\nTo import everything from std::f64::consts, you can use the wildcard * as so:\n{'use std::f64::consts::*'}\nYou can also combine it:\n{'use std::{f64::consts::{PI, TAU}, fmt::Debug};'}\nThis is equievalent to:\n{'use std::f64::consts::{PI, TAU};'}\nuse std::fmt::Debug;"},{"url":"http://localhost:15007/en/stages/2/cargo-subcommands","language":"en","stage":2,"index":6,"title":"Cargo Subcommands","tags":["cargo"],"previous":"managing-dependencies-with-cargo","next":"setup-visual-studio-code","content":"cargo subcommands are an option to add additional commands which are developed by the community to customize your developing experience.\nTo install a cargo subcommand, you simply run: cargo install name-of-subcommand\nFor example to install the cargo-watch subcommand, you simply run: cargo install cargo-watch.\nTo see all available option for this new cargo subcommand, just run: cargo watch --help\ncargo watch is a pretty useful command to run or test your code everytime something has changed. It can be used like: cargo watch -x run. This would execute cargo run whenever it detects a change.\nThere are other useful commands like cargo-edit which adds multiple subcommands (cargo add, cargo rm and cargo upgrade) to handle dependencies via CLI commands.\nFurther cargo subcommands can be found here:"},{"url":"http://localhost:15007/en/stages/3/for","language":"en","stage":3,"index":6,"title":"for","tags":["iteration"],"previous":"while","next":"match","content":"Rust's for loop is a powerful upgrade. It iterates over values from any expression that evaluates into an iterator. What's an iterator? An iterator is an object that you can ask the question \"What's the next item you have?\" until there are no more items.\nWe'll explore this more in a future chapter. In the meantime, just know Rust makes it easy to create iterators that generate a sequence of integer numbers.\nThe .. operator creates an iterator that generates numbers from a start number up to but not including an end number.\nThe ..= operator creates an iterator that generates numbers from a start number up to and including an end number."},{"url":"http://localhost:15007/en/stages/4/tuple-like-structs","language":"en","stage":4,"index":6,"title":"Tuple-like Structs","tags":["struct"],"previous":"creating-data-in-memory","next":"unit-like-structs","content":"For conciseness, you can create structs that are used like a tuple.\nThis is a good practice to improve the readability of your code by giving the tuple a name."},{"url":"http://localhost:15007/en/stages/5/failable-main","language":"en","stage":5,"index":6,"title":"Failable Main","previous":"result","next":"error-handling","content":"the main function has the capability of returning a Result!"},{"url":"http://localhost:15007/en/stages/6/returning-ownership","language":"en","stage":6,"index":6,"title":"Returning Ownership","previous":"moving-ownership","next":"borrowing-ownership-with-references","content":"Ownership can also be returned from a function."},{"url":"http://localhost:15007/en/stages/7/raw-string-literals","language":"en","stage":7,"index":6,"title":"Raw String Literals","previous":"multi-line-string-literals","next":"string-literals-from-files","content":"Raw strings allow us to write a sequence of characters verbatim by starting with r#\" and ending with \"#. It lets us insert characters that might otherwise confuse a normal string as literals (like double quotes and backslashes)."},{"url":"http://localhost:15007/en/stages/8/polymorphism-with-traits","language":"en","stage":8,"index":6,"title":"Polymorphism With Traits","previous":"abstraction-with-selective-exposure","next":"implemented-methods-on-traits","content":"Rust supports polymorphism with traits. Traits allow us to associate a set of methods with a struct type.\nWe first define the signatures of methods of a trait within:\nWhen a struct implements a trait, it establishes a contract that allows us to indirectly interact with the struct through the trait type (e.g. &dyn MyTrait) without having to know the real type.\nA struct's implemented traits methods are defined within an implementation block:"},{"url":"http://localhost:15007/en/stages/9/the-dot-operator","language":"en","stage":9,"index":6,"title":"The Dot Operator .","previous":"the-dereference-operator","next":"smart-pointers","content":"The . operator is used in accessing fields and methods of a reference. It works a bit more subtly.\nWhoa, why didn't we need to add * before ref_f? This is because the . operator automatically dereferences a sequence of references."},{"url":"http://localhost:15007/en/stages/1/constants","language":"en","stage":1,"index":7,"title":"Constants","previous":"basic-type-conversion","next":"arrays","content":"Constants allow us to specify a common value that's used throughout our code many times efficiently. Instead of copying values like variables where they are used, constants directly replace the text identifier where they are used with their value at compile time.\nUnlike variables, constants must always have explicit types.\nConstant names are always in SCREAMING_SNAKE_CASE."},{"url":"http://localhost:15007/en/stages/10/creating-modules","language":"en","stage":10,"index":7,"title":"Creating Modules","previous":"referencing-multiple-items","next":"module-hierarchy","content":"When we think of code, we usually imagine a hierarchy of files organized in directories. Rust lets you create modules closely related to your file structure.\nThere are two ways in Rust to declare a module. For example, a module foo can be represented as:\na file named foo.rs\na directory named foo with a file mod.rs inside"},{"url":"http://localhost:15007/en/stages/2/setup-visual-studio-code","language":"en","stage":2,"index":7,"title":"Setup Visual Studio Code","previous":"cargo-subcommands","next":"writing-a-hello-world-program","content":"I recommend using Visual Studio Code for developing Rust programs.\nVisual Studio Code is a modular editor which can be extended with with useful tools (called extensions) to improve your developing experience for Rust programming.\nBesides the official Rust extension there are also extension packs which offers some additional tools often needed for Rust programming, e. g. an extension for TOML files.\nI can recommend you an extension pack of my own, which you can find here: Rust Extension Pack."},{"url":"http://localhost:15007/en/stages/3/match","language":"en","stage":3,"index":7,"title":"match","previous":"for","next":"returning-values-from-block-expressions","content":"Miss your switch statement? Rust has an incredibly useful keyword for matching all possible conditions of a value and executing a code path if the match is true. Let's see how this works for numbers. We will have more to say in future chapters on pattern matching more complex data. I promise you it will be worth the wait.\nmatch is exhaustive, so all cases must be handled.\nMatching combined with destructuring is by far one of the most common patterns you will see in all of Rust."},{"url":"http://localhost:15007/en/stages/4/unit-like-structs","language":"en","stage":4,"index":7,"title":"Unit-like Structs","tags":["struct"],"previous":"tuple-like-structs","next":"enums","content":"Structs do not have to have any fields at all.\nAs mentioned in Chapter 1 a unit is another word for an empty tuple (). This is why this kind of struct is called Unit-like.\nThis type of struct is rarely used."},{"url":"http://localhost:15007/en/stages/5/error-handling","language":"en","stage":5,"index":7,"title":"Error Handling","tags":["error-handling"],"previous":"failable-main","next":"ugly-option-result-handling","content":"Result is so common that Rust has a powerful operator ? for working with them. These two statements are equivalent:\ndo_something_that_might_fail()?"},{"url":"http://localhost:15007/en/stages/6/borrowing-ownership-with-references","language":"en","stage":6,"index":7,"title":"Borrowing Ownership With References","previous":"returning-ownership","next":"borrowing-mutable-ownership-with-references","content":"References allow us borrow access to a resource with the & operator.\nReferences are also dropped like other resources."},{"url":"http://localhost:15007/en/stages/7/string-literals-from-files","language":"en","stage":7,"index":7,"title":"String Literals From Files","previous":"raw-string-literals","next":"string-slice","content":"If you have some very large text, consider using the macro include_str! to include text from local files in your program:\nlet hello_html = include_str!(\"hello.html\");"},{"url":"http://localhost:15007/en/stages/8/implemented-methods-on-traits","language":"en","stage":8,"index":7,"title":"Implemented Methods On Traits","previous":"polymorphism-with-traits","next":"trait-inheritance","content":"Traits can have implemented methods.\nThe functions have no direct access to the inner fields of a struct, but it can be useful for sharing behavior between many trait implementors."},{"url":"http://localhost:15007/en/stages/9/smart-pointers","language":"en","stage":9,"index":7,"title":"Smart Pointers","previous":"the-dot-operator","next":"smart-unsafe-code","content":"In addition to the ability to create references to existing typed data using the & operator, Rust gives us the ability to create reference-like structs called smart pointers.\nWe can think of references at a high level as a type that give us access to another type. Smart pointers are different in their behavior from normal references in that they operate based on internal logic that a programmer writes. You — the programmer — are the smart part.\nTypically smart pointers implement Deref, DerefMut, and Drop traits to specify the logic of what should happen when the structure is dereferenced with * and . operators."},{"url":"http://localhost:15007/en/stages/1/arrays","language":"en","stage":1,"index":8,"title":"Arrays","tags":["arrays"],"previous":"constants","next":"functions","content":"An array is a fixed length collection of data elements all of the same type.\nThe data type for an array is [T; N] where T is the elements' type, and N is the fixed length known at compile-time.\nIndividual elements can be retrieved with the [x] operator where x is a usize index (starting at 0) of the element you want.\nCollections with a dynamic length, often called dynamic or variable arrays, are introduced in a later chapter about Vectors."},{"url":"http://localhost:15007/en/stages/10/module-hierarchy","language":"en","stage":10,"index":8,"title":"Module Hierarchy","previous":"referencing-multiple-items","next":"inline-modules","content":"A module can depend on another one. In order to establish a relationship between a module and its sub-module, you must write in the parent module:\nmod foo;\nThe declaration above will look for a file named foo.rs or foo/mod.rs and will insert its contents inside a module named foo under this scope."},{"url":"http://localhost:15007/en/stages/2/writing-a-hello-world-program","language":"en","stage":2,"index":8,"title":"Writing A Hello World Program","tags":["program"],"previous":"setup-visual-studio-code","next":"reading-command-line-arguments","content":"You can create a new file main.rs and put the code from the Rust Playground in it\nor you can use cargo to create a new project with either cargo new hello-world or cargo init\ncargo will automatically create a src/main.rs for you which already has a Hello, world! output in it.\nIf you chose cargo to create a basic project for you, all you have to do is to run: cargo run in a terminal and you should see the output: Hello, world!\nIf you created a main.rs without cargo, you have to use the Rust compiler rustc and run: rustc main.rs.\nThis will create a main.exe in the same directory. Now you have to execute this compiled file (./main.exe) and you will see the same output.\nIn a later lesson you will also learn how to split your code into multiple files."},{"url":"http://localhost:15007/en/stages/3/returning-values-from-block-expressions","language":"en","stage":3,"index":8,"title":"Returning Values From Block Expressions","previous":"match","next":"summary","content":"if, match, functions, and scope blocks all have a unique way of returning values in Rust.\nIf the last statement in an if, match, function, or scope block is an expression without a ;, Rust will return it as a value from the block. This is a great way to create concise logic that returns a value that can be put into a new variable.\nNotice that it also allows an if statement to operate like a concise ternary expression."},{"url":"http://localhost:15007/en/stages/4/enums","language":"en","stage":4,"index":8,"title":"Enums","tags":["enum"],"previous":"unit-like-structs","next":"enums-with-data","content":"Enums allow you to create a new type that can have a value of several tagged elements using the enum keyword.\nmatch helps ensure exhaustive handling of all possible enum values making it a powerful tool in ensuring quality code."},{"url":"http://localhost:15007/en/stages/5/ugly-option-result-handling","language":"en","stage":5,"index":8,"title":"Ugly Option / Result Handling","tags":["generics","enum"],"previous":"error-handling","next":"vectors","content":"Working with Option / Result can be tedious when you are just trying to write some quick code. Both Option and Result have a function called unwrap that can be useful for getting a value in a quick and dirty manner. unwrap will:\nGet the value inside Option/Result\nIf the enum is of type None/Err, panic!\nThese two pieces of code are equivalent:\nSimilarly:\nBe a good rustacean and properly use match when you can!"},{"url":"http://localhost:15007/en/stages/6/borrowing-mutable-ownership-with-references","language":"en","stage":6,"index":8,"title":"Borrowing Mutable Ownership With References","previous":"borrowing-ownership-with-references","next":"dereferencing","content":"We can also borrow mutable access to a resource with the &mut operator.\nA resource owner cannot be moved or modified while mutably borrowed.\nMemory details:\nRust prevents having two ways to mutate an owned value because it introduces the possibility of a data race."},{"url":"http://localhost:15007/en/stages/7/string-slice","language":"en","stage":7,"index":8,"title":"String Slice","previous":"string-literals-from-files","next":"chars","content":"A string slice is a reference to a sequence of bytes in memory that must always be valid utf-8.\nA string slice (a sub-slice) of a str slice, must also be valid utf-8.\nCommon methods of &str:\nlen gets the length of the string literal in bytes (not number of characters).\nstarts_with / ends_with for basic testing.\nis_empty returns true if zero length.\nfind returns an {'Option'} of the first position of some text."},{"url":"http://localhost:15007/en/stages/8/trait-inheritance","language":"en","stage":8,"index":8,"title":"Trait Inheritance","previous":"implemented-methods-on-traits","next":"dynamic-vs-static-dispatch","content":"Traits can inherit methods from other traits."},{"url":"http://localhost:15007/en/stages/9/smart-unsafe-code","language":"en","stage":9,"index":8,"title":"Smart Unsafe Code","previous":"smart-pointers","next":"familiar-friends","content":"Smart pointers tend to use unsafe code fairly often. As mentioned earlier, they are common tools for interacting with the lowest levels of memory in Rust.\nWhat is unsafe code? Unsafe code behaves exactly like normal Rust with the exception of a few abilities that the Rust compiler is unable to make guarantees about.\nA primary ability of unsafe code is dereferencing a raw pointer. That means taking a raw pointer to a position in memory and declaring \"a data structure exists here!\" and turning it into a representation of data you can use (i.e. *const u8 into u8). Rust has no way to keep track of the meaning of every byte that gets written to memory. Because Rust can't make guarantees about what exists at an arbitrary number used as a raw pointer, it puts the dereference in an unsafe {'{ ... }'} block.\nSmart pointers dereference raw pointers extensively, but they are well proven in what they do."},{"url":"http://localhost:15007/en/stages/1/functions","language":"en","stage":1,"index":9,"title":"Functions","tags":["functions"],"previous":"arrays","next":"multiple-return-values","content":"A function has zero or more parameters.\nIn this example, the add function takes two arguments of type i32 (signed integer of 32-bit length).\nIf you just want to return an expression, you can drop the return keyword and the semicolon at the end, as we did in the subtract function.\nFunction names are always in snake_case.\nHint: if you define a function, the data it accepts are called parameters. If you call that function and pass data to it, then it's called arguments."},{"url":"http://localhost:15007/en/stages/10/inline-modules","language":"en","stage":10,"index":9,"title":"Inline Modules","previous":"module-hierarchy","next":"internal-module-referencing","content":"A sub-module can be directly inlined within a module's code.\nOne very common use for inline modules is creating unit tests. We create an inline module that only exists when Rust is used for testing! You already saw an example in a previous lesson.\nYou can also define modules inside modules, often called nested modules."},{"url":"http://localhost:15007/en/stages/2/reading-command-line-arguments","language":"en","stage":2,"index":9,"title":"Reading Command Line Arguments","previous":"writing-a-hello-world-program","next":"how-to-test-functions","content":"This one is a bit more difficult, but you will learn the used parts in later lessons.\nThis should you just give an example of how do you read arguments from the command line.\nIn programminging languages like C# or Java you always have to define a parameter for it, e. g. String args[]\nIn Rust this is not needed. To read arguments from the command line, you have to import the module std::env to collect arguments.\nthis is done by writing use std::env;. After it, you can use env in your file.\nWith {'let args: Vec = env::args().collect();'} your program will read all arguments in a dynamic String array, called Vector. This is similar to Java's parameter (String args[])\nVectors will be covered in a later section.\nSince this is a Vector we can't simply print it as a string. Therefore we have to add :? to the curly braces.\nFormatting will be covered in a later section, don't worry.\nYou can test it locally by creating a project with cargo new hello-arguments, adding the code from the Rust Playground and then call it with cargo run hello world\nThen you should see the output: Your arguments are [\"target\\\\debug\\\\hello-arguments.exe\", \"hello\", \"world\"]"},{"url":"http://localhost:15007/en/stages/3/summary","language":"en","stage":3,"index":9,"title":"Summary","previous":"returning-values-from-block-expressions","content":"Hopefully I've shown a glimpse of Rust's power even in the most basic language features. We'll be talking about for and match even more in depth as we gain more knowledge that can utilize their capabilities. Next time we'll get into Rust's foundational data structures."},{"url":"http://localhost:15007/en/stages/4/enums-with-data","language":"en","stage":4,"index":9,"title":"Enums With Data","tags":["enum"],"previous":"enums","next":"summary","content":"enum elements can also have one or more data types allowing them to behave like union from C.\nWhen an enum is pattern matched using match, you can bind a variable name to each data value.\nMemory details of enum:\nAn enum data value will have a memory size equal to its largest element. This allows for all potential values to fit in the same space of memory.\nIn addition to element data types (if any), each element also has a numeric value that represents which tag it is.\nOther details:\nRust's enum is something also known as a tagged union.\nThe combining of types to make a new type is what people mean when they say Rust has algebraic types."},{"url":"http://localhost:15007/en/stages/5/vectors","language":"en","stage":5,"index":9,"title":"Vectors","tags":["generics","macro","iteration"],"previous":"ugly-option-result-handling","next":"summary","content":"Some of the most useful generic types are collection types. A vector is a variably sized list of items represented by the struct Vec.\nThe macro vec! lets us easily create a vector rather than manually constructing one.\nVec has the method iter() which creates an iterator from a vector, allowing us to easily put a vector into a for loop.\nMemory Details:\nVec is a struct, but internally it contains a reference to a fixed list of its items on the heap.\nA vector starts with a default capacity; when more items are added than it has capacity for, it reallocates its data on the heap to have a new fixed list with large capacity."},{"url":"http://localhost:15007/en/stages/6/dereferencing","language":"en","stage":6,"index":9,"title":"Dereferencing","previous":"borrowing-mutable-ownership-with-references","next":"passing-around-borrowed-data","content":"Using &mut references, you can set the owner's value using the * operator.\nYou can also get a copy of an owned value using the * operator (if the value can be copied - we will discuss copyable types in later chapters)."},{"url":"http://localhost:15007/en/stages/7/chars","language":"en","stage":7,"index":9,"title":"Chars","previous":"string-slice","next":"string","content":"With so much difficulty in working with Unicode, Rust offers a way to retrieve a sequence of utf-8 bytes as a vector of characters of type char.\nA char is always 4 bytes long (allowing for efficient lookup of individual characters)."},{"url":"http://localhost:15007/en/stages/8/dynamic-vs-static-dispatch","language":"en","stage":8,"index":9,"title":"Dynamic vs Static Dispatch","previous":"trait-inheritance","next":"trait-objects","content":"Methods are executed in two ways:\nstatic dispatch - When the instance type is known, we have direct knowledge of what function to call.\ndynamic dispatch - When an instance type is not known, we must find out some way of calling the correct function.\nTrait types &dyn MyTrait give us the ability to work with instances of objects indirectly using dynamic dispatch.\nWhen dynamic dispatch is used, Rust will encourage you to put dyn before your trait type so people are aware.\nMemory details:\nDynamic dispatch is slightly slower because of the pointer chasing to find the real function call."},{"url":"http://localhost:15007/en/stages/9/familiar-friends","language":"en","stage":9,"index":9,"title":"Familiar Friends","previous":"smart-unsafe-code","next":"heap-allocated-memory","content":"Consider some smart pointers we've already seen like {'Vec'} and String. {'Vec'} is a smart pointer that just owns some memory region of bytes. The Rust compiler has no idea what exists in these bytes. The smart pointer interprets what it means to grab items from the region of memory it manages, keeps track of where data structures within those bytes begin and end, and then finally dereferences a raw pointer into data structures into a nice clean ergonomic interface for us to use (e.g. my_vec[3]).\nSimilarly, String keeps track of a memory region of bytes, and programmatically restricts content written to it to always be valid UTF-8 and helps dereference that memory region into a type &str.\nBoth these datastructures use unsafe dereferencing of raw pointers to do their job.\nMemory details:\nRust has an equivalent of C's malloc using alloc and Layout for getting ahold of your own memory regions to manage."},{"url":"http://localhost:15007/en/stages/1/multiple-return-values","language":"en","stage":1,"index":10,"title":"Multiple Return Values","previous":"functions","next":"returning-nothing","content":"Functions can return multiple values by returning a tuple of values.\nTuple elements can be referenced by their index number.\nRust supports various kinds of destructuring that we will see in many forms, allowing us to extract sub-pieces of data structures in ergonomic ways. Be on the lookout!"},{"url":"http://localhost:15007/en/stages/10/internal-module-referencing","language":"en","stage":10,"index":10,"title":"Internal Module Referencing","previous":"inline-modules","next":"exporting","content":"Rust has several keywords you can use in your use path to quickly get ahold of the module you want:\ncrate - the root module of your crate\nsuper - the parent module of your current module\nself - the current module"},{"url":"http://localhost:15007/en/stages/2/how-to-test-functions","language":"en","stage":2,"index":10,"title":"How to test functions","tags":["testing"],"previous":"reading-command-line-arguments","next":"summary","content":"Rust provides a built-in testing tool with cargo test\nSince you don't want testing code being a part of your production program, you have to tell the Rust compiler that it's for testing only.\nYou can do that by annotating #[cfg(test)]. Rust will compile all code after it only if you run cargo test.\nAfter this annotation, we will create an own module (container) for our test with mod test {'{ }'}.\nSince functions are block-scoped, we have to tell our module, to import everthing from the outer module with use super::*;\nNow we are good to go and can write actual test functions. Since there can be setup functions or utility functions, you have to tell cargo test which function should be tested by annotating it with #[test]\nFinally we have 3 assert macros to actually test a function. To test if something is equal (assert_eq!), not equal (assert_ne!) or if something is simply true (assert!).\nYou will learn all those new things in detail in later lessons. Don't worry."},{"url":"http://localhost:15007/en/stages/4/summary","language":"en","stage":4,"index":10,"title":"Summary","previous":"enums-with-data","content":"How exciting! We now have the most basic tools for representing the form of our ideas in code. Hopefully now we can see a glimmer of how Rust's fundamental operations work in harmony and conciseness with its types. Next up we will talk about a concept that gives our data types even more flexibility of representation: generics."},{"url":"http://localhost:15007/en/stages/5/summary","language":"en","stage":5,"index":10,"title":"Summary","previous":"vectors","content":"In one chapter we've learned how much power generic types give us! Don't worry if you don't know fully how to use everything, right now it's just good to be aware of the major ideas you will see again and again in code. Our functions are getting quite lengthy! In our next chapter we will spend talk about an important concept in Rust: data ownership."},{"url":"http://localhost:15007/en/stages/6/passing-around-borrowed-data","language":"en","stage":6,"index":10,"title":"Passing Around Borrowed Data","previous":"dereferencing","next":"references-of-references","content":"Rust's rules for references might best be summarized by:\nRust only allows there to be one mutable reference or multiple non-mutable references but not both.\nA reference must never live longer than its owner.\nThis doesn't tend to be a problem when passing around references to functions.\nMemory details:\nThe first rule of references prevents data races. What's a data race? A data race when reading from data has the possibility of being out of sync due to the existence of a writer to the data at the same time. This happens often in multi-threaded programming.\nThe second rule of references prevents the misuse of references that refer to non-existent data (called dangling pointers in C)."},{"url":"http://localhost:15007/en/stages/7/string","language":"en","stage":7,"index":10,"title":"String","previous":"chars","next":"text-as-function-parameters","content":"A String is a struct that owns a sequence of utf-8 bytes in heap memory.\nBecause its memory is on the heap, it can be extended, modified, etc. in ways string literals cannot.\nCommon methods are:\npush_str to add more utf-8 bytes to the end of a string.\nreplace to replace sequences of utf-8 bytes with others.\nto_lowercase / to_uppercase for case changes.\ntrim for trimming space\nWhen a String is dropped, its heap memory is also dropped.\nString has a + operator that extends the string with a &str and returns itself, but it might not be as ergonomic as you hope for."},{"url":"http://localhost:15007/en/stages/8/trait-objects","language":"en","stage":8,"index":10,"title":"Trait Objects","previous":"dynamic-vs-static-dispatch","next":"handling-unsized-data","content":"When we pass an instance of an object to a parameter of type &dyn MyTrait we pass what is called a trait object.\nA trait object is what allows us to indirectly call the correct methods of an instance. A trait object is a struct that holds the pointer of our instance with a list of function pointers to our instance's methods.\nMemory details:\nThis list of functions is known in C++ as a vtable."},{"url":"http://localhost:15007/en/stages/9/heap-allocated-memory","language":"en","stage":9,"index":10,"title":"Heap Allocated Memory","previous":"familiar-friends","next":"failable-main-revisited","content":"Box is a smart pointer that lets us move data from the stack to the heap.\nDereferencing it lets us use the heap allocated data ergonomically as if it were the original type."},{"url":"http://localhost:15007/en/stages/1/returning-nothing","language":"en","stage":1,"index":11,"title":"Returning Nothing","previous":"multiple-return-values","next":"macros","content":"If no return type is specified for a function, it returns an empty tuple, also known as a unit.\nAn empty tuple is represented by ().\nUsing () is uncommon, but will come up often enough that it's good to know whats happening."},{"url":"http://localhost:15007/en/stages/10/exporting","language":"en","stage":10,"index":11,"title":"Exporting","previous":"internal-module-referencing","next":"struct-visibility","content":"By default members of a module are not accessible from outside of the module (not even to its child modules!). We make members of a module accessible using the pub keyword.\nBy default members of a crate are not accessible outside of the crate. We make members of a crate accessible by marking them as pub in the root module of your crate (lib.rs or main.rs)."},{"url":"http://localhost:15007/en/stages/2/summary","language":"en","stage":2,"index":11,"title":"Summary","previous":"how-to-test-functions","content":"In this stage you learned how to install Rust locally. You learned about the Rust tools rustup and cargo\nNow you know how to manage dependencies with cargo and extend it with cargo subcommands.\nYou also learned how to setup Visual Studio Code and you wrote your first Rust programs.\nNext up we'll be looking at some old friends: if tests and for loops."},{"url":"http://localhost:15007/en/stages/6/references-of-references","language":"en","stage":6,"index":11,"title":"References Of References","previous":"passing-around-borrowed-data","next":"explicit-lifetimes","content":"References can even be used on pieces of references."},{"url":"http://localhost:15007/en/stages/7/text-as-function-parameters","language":"en","stage":7,"index":11,"title":"Text As Function Parameters","previous":"string","next":"building-strings","content":"String literals and strings are generally passed around as a string slice to functions. This offers a lot of flexibility for most scenarios where you don't actually have to pass ownership."},{"url":"http://localhost:15007/en/stages/8/handling-unsized-data","language":"en","stage":8,"index":11,"title":"Handling Unsized Data","previous":"trait-objects","next":"generic-functions","content":"Traits introduce an interesting challenge when we want to store them within another struct. Traits obfuscate the original struct thus it also obfuscates the original size. Unsized values being stored in structs are handled in two ways in Rust:\ngenerics - Using parameterized types effectively create struct/functions known types and thus known sizes.\nindirection - Putting instances on the heap gives us a level of indirection that allow us to not have to worry about the size of the actual type and just store a pointer to it. There are other ways as well!"},{"url":"http://localhost:15007/en/stages/9/failable-main-revisited","language":"en","stage":9,"index":11,"title":"Failable Main Revisited","previous":"heap-allocated-memory","next":"referencing-counting","content":"Rust code may have a plethora of representations of errors, but the standard library has a universal trait std::error::Error for describing errors.\nUsing a smart pointer Box we can use the type {'Box'} as a common type for returning errors because it allows us to propagate up an error on the heap and interact with it at a high level without having to know a specific type.\nEarly in Rust Jungle we learned that the main function can return an error. We can now return a type capable of describing almost any kind of error that might occur in our program so long as the error's data structure implements Rust's common Error trait.\n{'fn main() -> Result<(), Box>'}"},{"url":"http://localhost:15007/en/stages/1/macros","language":"en","stage":1,"index":12,"title":"Macros","tags":["macros"],"previous":"returning-nothing","next":"compiler-messages","content":"We’ve used macros like println! throughout this stage, but we haven’t fully explored what a macro is and how it works. The term macro refers to a family of features in Rust: declarative macros with macro_rules! and three kinds of procedural macros:\nCustom #[derive] macros that specify code added with the derive attribute used on structs and enums\nAttribute-like macros that define custom attributes usable on any item\nFunction-like macros that look like function calls but operate on the tokens specified as their argument\nTo distinguish it from functions, macros are a way of writing code that writes other code, which is known as metaprogramming\nYou can write your own macros with macro_rules!"},{"url":"http://localhost:15007/en/stages/10/struct-visibility","language":"en","stage":10,"index":12,"title":"struct Visibility","previous":"exporting","next":"prelude","content":"Just like functions, structures can declare what they want exposed outside of their module using pub.\nThis is a similar defensive approach as with immutable variables by default."},{"url":"http://localhost:15007/en/stages/6/explicit-lifetimes","language":"en","stage":6,"index":12,"title":"Explicit Lifetimes","previous":"references-of-references","next":"multiple-lifetimes","content":"Even though Rust doesn't always show it in code, the compiler understands the lifetime of every variable and will attempt to validate that a reference never exists longer than its owner.\nFunctions can be explicit by parameterizing the function signature with symbols that help identify which parameters and return values share the same lifetime.\nLifetime specifiers always start with a ', e.g. 'a, 'b"},{"url":"http://localhost:15007/en/stages/7/building-strings","language":"en","stage":7,"index":12,"title":"Building Strings","previous":"text-as-function-parameters","next":"formatting-strings","content":"concat and join are two simple but powerful ways for building strings."},{"url":"http://localhost:15007/en/stages/8/generic-functions","language":"en","stage":8,"index":12,"title":"Generic Functions","tags":["generics","functions"],"previous":"handling-unsized-data","next":"generic-functions-shorthand","content":"Generics in Rust work hand in hand with traits. When we describe a parameterized type T we can constrain what types can be used as an argument by listing what required traits the argument must implement.\nIn this example type T must implement trait Foo:\nBy using generics we create static typed functions at compile time that will have known types and sizes, allowing us to perform static dispatch and store as a sized value."},{"url":"http://localhost:15007/en/stages/9/referencing-counting","language":"en","stage":9,"index":12,"title":"Referencing Counting","previous":"failable-main-revisited","next":"sharing-access","content":"Rc is a smart pointer that moves data from the stack onto the heap. It allows us to clone other Rc smart pointers that all have the ability to immutably borrow the data that was put on the heap.\nOnly when the last smart pointer is dropped does the data on the heap become deallocated."},{"url":"http://localhost:15007/en/stages/1/compiler-messages","language":"en","stage":1,"index":13,"title":"Compiler Messages","tags":["compiler"],"previous":"macros","next":"summary","content":"Compiler messages in Rust are really helpful and informative in most cases. The Rust team and the contributors are constantly improving the messages.\nCompiler messages consists of 4 parts:\nA short error message, sometimes with an error code, e. g. error[E0277]: `Foo` doesn't implement `Debug`\nThe code part, which is colorful and with underlines\nAn optional help block which provides solutions, which you can sometimes just copy & paste\nAn optional further information message, e. g. For more information about this error, try `rustc --explain E0277`\nRun the code from the Rust Playground and read the Standard Error block.\nYou can actually copy & paste the provided help to get your program working as expected.\nAfter it, your programm will look like this."},{"url":"http://localhost:15007/en/stages/10/prelude","language":"en","stage":10,"index":13,"title":"Prelude","previous":"struct-visibility","next":"your-own-prelude","content":"You might be wondering how we have access to Vec or Box everywhere without a use to import them. It is because of the module prelude in the standard library.\nKnow that in the Rust standard library anything that is exported in std::prelude::* is automatically available to every part of Rust. That is the case for Vec and Box but others as well (Option, Copy, etc.)."},{"url":"http://localhost:15007/en/stages/6/multiple-lifetimes","language":"en","stage":6,"index":13,"title":"Multiple Lifetimes","previous":"explicit-lifetimes","next":"static-lifetimes","content":"Lifetime specifiers allow us to be explicit with certain scenarios the compiler cannot resolve itself by distinguishing all of a function signature component's lifetimes."},{"url":"http://localhost:15007/en/stages/7/formatting-strings","language":"en","stage":7,"index":13,"title":"Formatting Strings","previous":"building-strings","next":"converting-strings","content":"The format! macro allows us to create a string by defining a parameterized string with placeholders for where and how values should be placed, e. g. {'{}'}).\nformat! uses the same parameterized strings as println!\nTo print arrays, structs, enums etc. you simple add :? to the curly brackets, e. g. {'{:?}'}\nYou can also use a pretty-print by adding :#? to the curly brackets, e. g. {'{:#?}'}"},{"url":"http://localhost:15007/en/stages/8/generic-functions-shorthand","language":"en","stage":8,"index":13,"title":"Generic Functions Shorthand","previous":"generic-functions-shorthand","next":"box","content":"Rust has a shorthand for expressing generics constrained by a trait:\nThis is equivalent to writing:"},{"url":"http://localhost:15007/en/stages/9/sharing-access","language":"en","stage":9,"index":13,"title":"Sharing Access","previous":"referencing-counting","next":"sharing-across-threads","content":"RefCell is a container data structure commonly held by smart pointers that takes in data and lets us borrow mutable and immutable references to what's inside. It prevents borrowing from being abused by enforcing Rust's memory safety rules at runtime when you ask to borrow the data within:\nOnly one mutable reference OR multiple immutable references, but not both!\nIf you violate these rules RefCell will panic."},{"url":"http://localhost:15007/en/stages/1/summary","language":"en","stage":1,"index":14,"title":"Summary","previous":"compiler-messages","content":"Nice job so far! The basics of Rust aren't so bad, right? We're getting a peek into how the Rust compiler thinks. As a system programming language it cares a lot about the size of values in memory, whether things can be modified or not, and making sure your math is what you want it to be.\nIn the next stage we will learn how to install Rust locally and how to develop and test a very simple program."},{"url":"http://localhost:15007/en/stages/10/your-own-prelude","language":"en","stage":10,"index":14,"title":"Your Own Prelude","previous":"prelude","next":"cargo-toml-file","content":"Because of standard library's prelude, it's common for your libary to have its own prelude module as a starting point for where users should import all of the most common data structures for using your library (e.g use my_library::prelude::*). It doesn't automatically get used in programs/libraries that use your crate, but it's a good convention to follow so people know where to start.\nFerris says, \"Be a good rustacean and help a fellow crab out with a good prelude!\""},{"url":"http://localhost:15007/en/stages/6/static-lifetimes","language":"en","stage":6,"index":14,"title":"Static Lifetimes","previous":"multiple-lifetimes","next":"lifetimes-in-data-types","content":"A static variable is a memory resource created at compile-time that exists through a program start to finish. They must have their types explicitly specified.\nA static lifetime is a memory resource that lasts indefinitely to the end of a program. Note that by this definition some static lifetime resources can be created at runtime.\nResources with static lifetimes have a special lifetime specifier 'static.\n'static resources will never drop.\nIf static lifetime resources contain references they must all be 'static (anything less would not live long enough).\nMemory details:\nModifying static variables is inherently dangerous because they are globally accessable to be read from by anyone introducing the possibility of a data race. We'll talk about the challenges of global data later.\nRust allows the use of unsafe {'{'} ... {'}'} blocks to perform some operations that the compiler cannot make memory guarantees about. The Rustnomicon (aka The Dark Arts of Unsafe Rust) should not be talked about casually - it's like the restricted section from Harry Potter."},{"url":"http://localhost:15007/en/stages/7/converting-strings","language":"en","stage":7,"index":14,"title":"Converting Strings","previous":"formatting-strings","next":"useful-string-methods","content":"Many types can be converted to a string using to_string.\nThe generic function parse can be used to convert strings or string literals into a typed value. This function returns a Result because it could fail."},{"url":"http://localhost:15007/en/stages/8/box","language":"en","stage":8,"index":14,"title":"Box","previous":"generic-functions-shorthand","next":"generic-structs-revisited","content":"Box is a data structure that allows us to move our data from the stack to the heap.\nBox is a struct known as a smart pointer that holds the pointer to our data on the heap.\nBecause Box is a struct with a known size (because it just holds a pointer), it is often used as a way to store a reference to something in a struct that must know the size of its fields.\nBox is so common it can be used from anywhere:\nBox::new(Foo {'{ ... }'})"},{"url":"http://localhost:15007/en/stages/9/sharing-across-threads","language":"en","stage":9,"index":14,"title":"Sharing Across Threads","previous":"sharing-access","next":"combining-smart-pointers","content":"Mutex (abbreviation for mutual exclusion) is a container data structure commonly held by smart pointers that takes in data and lets us borrow mutable and immutable references to the data within. This prevents borrowing from being abused by having the operating system restrict only one CPU thread at time to have access to the data, blocking other threads until that original thread is done with its locked borrow.\nMultithreading is beyond the scope of Rust Jungle, but Mutex is a fundamental part of orchestrating multiple CPU threads accessing the same data.\nThere is a special smart pointer Arc which is identical to Rc except uses thread-safe incrementing of reference counts. It's often used to have many references to the same Mutex."},{"url":"http://localhost:15007/en/stages/10/cargo-toml-file","language":"en","stage":10,"index":15,"title":"Cargo.toml File","previous":"your-own-prelude","next":"rust-editions","content":"The Cargo.toml file is the central configuration file when you decide to use cargo.\nIt's automatically created with cargo new / init.\nIn the Cargo.toml file you can define:\npackage information like name, version, author or edition\ntarget information\ndependencies\nworkspaces\nprofiles\nfeatures\nBesides the Cargo.toml there will be a Cargo.lock file which consists of a table of your dependencies with concret version"},{"url":"http://localhost:15007/en/stages/6/lifetimes-in-data-types","language":"en","stage":6,"index":15,"title":"Lifetimes In Data Types","previous":"static-lifetimes","next":"summary","content":"Similarly to functions, data types can be parameterized with lifetime specifiers of its members.\nRust validates that the containing data structure of the references never lasts longer than the owners its references point to.\nWe can't have structs running around with references pointing to nothingness!"},{"url":"http://localhost:15007/en/stages/7/useful-string-methods","language":"en","stage":7,"index":15,"title":"Useful String Methods","previous":"converting-strings","next":"regular-expressions","content":"Ferris will show you some useful string methods:\n\"\".replace(from, to) - to replace a part of a string\n\"\".len() - to get the length of a string\n\"\".pop() - remove the last character and returns it\n\"\".push_str() - append a string at the end\n\"\".trim() - remove leading and trailing whitespaces. There are also more specific trim methods\n\"\".to_lowercase() - transform all letters to lowercase\n\"\".to_uppercase() - transform all letters to uppercase\n\"\".is_empty() - returns true if the string is empty (length of zero)\n&\"\"[M..N] - substrings are done with the index operator [M..N]"},{"url":"http://localhost:15007/en/stages/8/generic-structs-revisited","language":"en","stage":8,"index":15,"title":"Generic Structs Revisited","tags":["generics","struct"],"previous":"box","next":"summary","content":"Generic structs can also have their parameterized types constrained by traits:\nGeneric structs have their parameterized type in their implementation blocks:"},{"url":"http://localhost:15007/en/stages/9/combining-smart-pointers","language":"en","stage":9,"index":15,"title":"Combining Smart Pointers","previous":"sharing-across-threads","next":"summary","content":"Smart pointers might seem limited, but they can make some very powerful combinations.\n{'Rc<Vec> '} - Allow the cloning of multiple smart pointers that can borrow the same vector of immutable data structures on the heap. {'Rc<RefCell>'} - Allow multiple smart pointers the ability to borrow mutably/immutably the same struct Foo {'Arc<Mutex>'} - Allow multiple smart pointers the ability to lock temporary mutable/immutable borrows in a CPU thread exclusive manner.\nMemory details:\nYou'll notice a theme with many of these combinations. The use of a immutable data type (possibly owned by multiple smart pointers) to modify internal data. This is referred to as the \"interior mutability\" pattern in Rust. It is a pattern that lets us bend the rules of memory usage at runtime with the same level of safety as Rust's compile-time checks."},{"url":"http://localhost:15007/en/stages/10/rust-editions","language":"en","stage":10,"index":16,"title":"Rust Editions","previous":"cargo-toml-file","next":"summary","content":"Rust ships new releases on a six-week cycle and you can easily update to it with rustup update.\nThis means you will get constantly new, but smaller updates, not only for Rust, but also for the other tools like cargo or rustup.\nBesides regular Rust updates, every 2 or 3 years the Rust team releases a new edition. You can set your Rust edition in the Cargo.toml file.\nNew editions can add new keywords which could conflict or be incompatible with your existing code. Therefore you have to opt-in to use a newer edition or you just stay on a working edition and everything is fine.\nThe Rust compiler will support all editions that existed prior to the compiler's release, and can link crates of any supported editions together."},{"url":"http://localhost:15007/en/stages/6/summary","language":"en","stage":6,"index":16,"title":"Summary","previous":"lifetimes-in-data-types","content":"Whew, congrats for making it through! I know it's a lot to take in, but you are well under way to becoming a Rustacean. Hopefully it's clear how Rust as a language aims to solve many of these common challenges in systems programming:\nUnintentional modification of resources\nForgetting to deconstruct resources\nResources accidentally being deconstructed twice\nUsing resources after they have been deconstructed\nData races caused by writing to resources while others are reading from resources\nSeeing clearly areas of the code where the compiler can’t make guarantees\nIn the next chapter we'll apply some of this knowledge as we look at how Rust handles text."},{"url":"http://localhost:15007/en/stages/7/regular-expressions","language":"en","stage":7,"index":16,"title":"Regular Expressions","previous":"useful-string-methods","next":"summary","content":"Regular Expressions (regex) is a common tool to check if text meets a predefined criteria.\nCommon use cases for it are email, number or domain verifications.\nRust provides the module regex::Regex to deal with regex.\nBut before you can start, you have to add regex = \"1\" to your Cargo.toml dependencies\nA regex check consists of 3 parts:\nA pattern which you define with Regex::new()\nA string to check\nThe actual check with is_match(), which will return a bool"},{"url":"http://localhost:15007/en/stages/8/summary","language":"en","stage":8,"index":16,"title":"Summary","previous":"generic-structs-revisited","content":"We now have more language features at hand to represent our ideas clearly! Rust abstractions might be simple but they are powerful enough to make working with code a joy. In this chapter, we caught a glimpse of smart pointers with Box. In the next chapter we'll learn about how smart pointers can help us with other specialized memory situations."},{"url":"http://localhost:15007/en/stages/9/summary","language":"en","stage":9,"index":16,"title":"Summary","previous":"combining-smart-pointers","content":"Smart pointers are the idioms of Rust programming and let us not have to re-create the very common patterns of memory usage. With them you are ready to tackle the toughest of challenges! Now that we have the foundations of Rust, let's talk a bit about how we make larger projects. In chapter 9 we break free of single page lines of code."},{"url":"http://localhost:15007/en/stages/10/summary","language":"en","stage":10,"index":17,"title":"Summary","previous":"rust-editions","content":"You now have a few tricks up your sleeve when it comes to creating Rust applications and libraries ready for the world. Don't worry about remembering it all. As your library grows and is used by other people, you'll find what works best at each milestone.\nIf you want to practice your new Rust skills, I can recommend you Rustlings. This is an interactive tutorial by the Rust team."},{"url":"http://localhost:15007/en/stages/7/summary","language":"en","stage":7,"index":17,"title":"Summary","previous":"useful-string-method","content":"Now you know the basics of text! As you have seen, Unicode makes working with text a bit tricky, but the standard library has plenty of functionality to make it easy to manage.\nUp to now, we've mostly looked at Rust from the lens of a procedural paradigm (i.e. just functions and data), but it's time we now talk about traits and the capabilities unlocked by Rust's object oriented paradigm."}]}